From 9f998a37a9d3d3acdb500f9c6aa02db719ba0387 Mon Sep 17 00:00:00 2001
From: shinchiro <shinchiro@users.noreply.github.com>
Date: Sat, 28 Oct 2017 03:36:33 +0800
Subject: [PATCH] Revert "libavformat: not treat 0 as EOF"

---
 libavcodec/version.h  |  2 ++
 libavformat/avio.c    |  6 ++----
 libavformat/aviobuf.c | 20 ++++++++------------
 libavformat/cache.c   |  4 ++--
 libavformat/concat.c  |  9 ++++-----
 libavformat/http.c    |  5 +----
 6 files changed, 19 insertions(+), 27 deletions(-)

diff --git a/libavcodec/version.h b/libavcodec/version.h
index 226da1935f..fc5018efe9 100644
--- a/libavcodec/version.h
+++ b/libavcodec/version.h
@@ -41,6 +41,8 @@
 
 #define LIBAVCODEC_IDENT        "Lavc" AV_STRINGIFY(LIBAVCODEC_VERSION)
 
+#define LIBAVCODEC_MPV 1
+
 /**
  * FF_API_* defines may be placed below to indicate public API that will be
  * dropped at a future version bump. The defines themselves are not part of
diff --git a/libavformat/avio.c b/libavformat/avio.c
index 4dc468350c..af3e5ab867 100644
--- a/libavformat/avio.c
+++ b/libavformat/avio.c
@@ -391,10 +391,8 @@ static inline int retry_transfer_wrapper(URLContext *h, uint8_t *buf,
                 }
                 av_usleep(1000);
             }
-        } else if (ret == AVERROR_EOF)
-            return (len > 0) ? len : AVERROR_EOF;
-        else if (ret < 0)
-            return ret;
+        } else if (ret < 1)
+            return (ret < 0 && ret != AVERROR_EOF) ? ret : len;
         if (ret) {
             fast_retries = FFMAX(fast_retries, 2);
             wait_since = 0;
diff --git a/libavformat/aviobuf.c b/libavformat/aviobuf.c
index 3e9d774a13..d1171f9082 100644
--- a/libavformat/aviobuf.c
+++ b/libavformat/aviobuf.c
@@ -565,14 +565,13 @@ static void fill_buffer(AVIOContext *s)
     if (s->read_packet)
         len = s->read_packet(s->opaque, dst, len);
     else
-        len = AVERROR_EOF;
-    if (len == AVERROR_EOF) {
+        len = 0;
+    if (len <= 0) {
         /* do not modify buffer if EOF reached so that a seek back can
            be done without rereading data */
         s->eof_reached = 1;
-    } else if (len < 0) {
-        s->eof_reached = 1;
-        s->error= len;
+        if (len < 0)
+            s->error = len;
     } else {
         s->pos += len;
         s->buf_ptr = dst;
@@ -640,16 +639,13 @@ int avio_read(AVIOContext *s, unsigned char *buf, int size)
                 // bypass the buffer and read data directly into buf
                 if(s->read_packet)
                     len = s->read_packet(s->opaque, buf, size);
-                else
-                    len = AVERROR_EOF;
-                if (len == AVERROR_EOF) {
+
+                if (len <= 0) {
                     /* do not modify buffer if EOF reached so that a seek back can
                     be done without rereading data */
                     s->eof_reached = 1;
-                    break;
-                } else if (len < 0) {
-                    s->eof_reached = 1;
-                    s->error= len;
+                    if(len<0)
+                        s->error= len;
                     break;
                 } else {
                     s->pos += len;
diff --git a/libavformat/cache.c b/libavformat/cache.c
index 66bbbf54c9..6aabca2e78 100644
--- a/libavformat/cache.c
+++ b/libavformat/cache.c
@@ -201,7 +201,7 @@ static int cache_read(URLContext *h, unsigned char *buf, int size)
     }
 
     r = ffurl_read(c->inner, buf, size);
-    if (r == AVERROR_EOF && size>0) {
+    if (r == 0 && size>0) {
         c->is_true_eof = 1;
         av_assert0(c->end >= c->logical_pos);
     }
@@ -263,7 +263,7 @@ resolve_eof:
                 if (whence == SEEK_SET)
                     size = FFMIN(sizeof(tmp), pos - c->logical_pos);
                 ret = cache_read(h, tmp, size);
-                if (ret == AVERROR_EOF && whence == SEEK_END) {
+                if (ret == 0 && whence == SEEK_END) {
                     av_assert0(c->is_true_eof);
                     goto resolve_eof;
                 }
diff --git a/libavformat/concat.c b/libavformat/concat.c
index 19c83c309a..46b520fe80 100644
--- a/libavformat/concat.c
+++ b/libavformat/concat.c
@@ -135,20 +135,19 @@ static int concat_read(URLContext *h, unsigned char *buf, int size)
 
     while (size > 0) {
         result = ffurl_read(nodes[i].uc, buf, size);
-        if (result == AVERROR_EOF) {
+        if (result < 0)
+            return total ? total : result;
+        if (!result) {
             if (i + 1 == data->length ||
                 ffurl_seek(nodes[++i].uc, 0, SEEK_SET) < 0)
                 break;
-            result = 0;
         }
-        if (result < 0)
-            return total ? total : result;
         total += result;
         buf   += result;
         size  -= result;
     }
     data->current = i;
-    return total ? total : result;
+    return total;
 }
 
 static int64_t concat_seek(URLContext *h, int64_t pos, int whence)
diff --git a/libavformat/http.c b/libavformat/http.c
index bd9148f45d..668cd51986 100644
--- a/libavformat/http.c
+++ b/libavformat/http.c
@@ -1296,11 +1296,8 @@ static int http_buf_read(URLContext *h, uint8_t *buf, int size)
                    "Chunked encoding data size: %"PRIu64"'\n",
                     s->chunksize);
 
-            if (!s->chunksize) {
-                av_log(h, AV_LOG_DEBUG, "Last chunk received, closing conn\n");
-                ffurl_closep(&s->hd);
+            if (!s->chunksize)
                 return 0;
-            }
             else if (s->chunksize == UINT64_MAX) {
                 av_log(h, AV_LOG_ERROR, "Invalid chunk size %"PRIu64"\n",
                        s->chunksize);
-- 
2.14.2

