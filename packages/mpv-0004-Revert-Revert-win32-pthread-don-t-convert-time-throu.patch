From b764c151fd310c5028f8fca82675542d6f663655 Mon Sep 17 00:00:00 2001
From: rorgoroth <77244135+rorgoroth@users.noreply.github.com>
Date: Sat, 21 Oct 2023 12:48:16 +0100
Subject: [PATCH 4/4] Revert "Revert "win32/pthread: don't convert time through
 unrelated timer""

This reverts commit 9f147496b50e1d281b61e9659401d0abdfc97d3f.
---
 osdep/timer.c         |  8 ++++++++
 osdep/win32/pthread.c | 22 ++++++----------------
 2 files changed, 14 insertions(+), 16 deletions(-)

diff --git a/osdep/timer.c b/osdep/timer.c
index 6e8ce7d65f..e939ef5dd5 100644
--- a/osdep/timer.c
+++ b/osdep/timer.c
@@ -27,6 +27,7 @@
 #include "common/msg.h"
 #include "misc/random.h"
 #include "timer.h"
+#include "config.h"
 
 static uint64_t raw_time_offset;
 static pthread_once_t timer_init_once = PTHREAD_ONCE_INIT;
@@ -72,6 +73,7 @@ int64_t mp_time_ns_add(int64_t time_ns, double timeout_sec)
     return time_ns + ti;
 }
 
+#if !HAVE_WIN32_INTERNAL_PTHREADS
 static int get_realtime(struct timespec *out_ts)
 {
 #if defined(_POSIX_TIMERS) && _POSIX_TIMERS > 0
@@ -85,13 +87,19 @@ static int get_realtime(struct timespec *out_ts)
     return 0;
 #endif
 }
+#endif
 
 struct timespec mp_time_ns_to_realtime(int64_t time_ns)
 {
     struct timespec ts = {0};
+
+#if !HAVE_WIN32_INTERNAL_PTHREADS
     if (get_realtime(&ts) != 0)
         return ts;
     int64_t time_rel = time_ns - mp_time_ns();
+#else
+    int64_t time_rel = time_ns;
+#endif
 
     // clamp to 1000 days in the future
     time_rel = MPMIN(time_rel, 1000 * 24 * 60 * 60 * INT64_C(1000000000));
diff --git a/osdep/win32/pthread.c b/osdep/win32/pthread.c
index d4884cf73f..8bc39777ab 100644
--- a/osdep/win32/pthread.c
+++ b/osdep/win32/pthread.c
@@ -23,6 +23,7 @@
 #include <assert.h>
 #include <windows.h>
 
+#include "common/common.h"
 #include "osdep/timer.h"  // mp_{start,end}_hires_timers
 
 int pthread_once(pthread_once_t *once_control, void (*init_routine)(void))
@@ -104,22 +105,11 @@ int pthread_cond_timedwait(pthread_cond_t *restrict cond,
                            pthread_mutex_t *restrict mutex,
                            const struct timespec *restrict abstime)
 {
-    // mpv uses mingw's gettimeofday() as time source too.
-    struct timeval tv;
-    gettimeofday(&tv, NULL);
-    DWORD timeout_ms = 0;
-    if (abstime->tv_sec >= INT64_MAX / 10000) {
-        timeout_ms = INFINITE;
-    } else if (abstime->tv_sec >= tv.tv_sec) {
-        long long msec = (abstime->tv_sec - tv.tv_sec) * 1000LL +
-            abstime->tv_nsec / 1000LL / 1000LL - tv.tv_usec / 1000LL;
-        if (msec > INT_MAX) {
-            timeout_ms = INFINITE;
-        } else if (msec > 0) {
-            timeout_ms = msec;
-        }
-    }
-    return cond_wait(cond, mutex, timeout_ms);
+    // mp time is not converted to realtime if internal pthread impl is used
+    int64_t now = mp_time_ns();
+    int64_t time_ns = abstime->tv_sec * UINT64_C(1000000000) + abstime->tv_nsec;
+    int64_t timeout_ms = (time_ns - now) / INT64_C(1000000);
+    return cond_wait(cond, mutex, MPCLAMP(timeout_ms, 0, INFINITE));
 }
 
 int pthread_cond_wait(pthread_cond_t *restrict cond,
-- 
2.40.1

