From fd5804fd2ad241c931ed512f5ab08755e4913279 Mon Sep 17 00:00:00 2001
From: wm4 <nfxjfg@googlemail.com>
Date: Fri, 27 Oct 2017 17:55:29 +0200
Subject: [PATCH 01/16] Revert "libavformat: not treat 0 as EOF"

This reverts commit 858db4b01fa2b55ee55056c033054ca54ac9b0fd.
---
 libavformat/avio.c    |  6 ++----
 libavformat/aviobuf.c | 20 ++++++++------------
 libavformat/cache.c   |  4 ++--
 libavformat/concat.c  |  9 ++++-----
 libavformat/http.c    |  5 +----
 5 files changed, 17 insertions(+), 27 deletions(-)

diff --git a/libavformat/avio.c b/libavformat/avio.c
index 4dc468350c..af3e5ab867 100644
--- a/libavformat/avio.c
+++ b/libavformat/avio.c
@@ -391,10 +391,8 @@ static inline int retry_transfer_wrapper(URLContext *h, uint8_t *buf,
                 }
                 av_usleep(1000);
             }
-        } else if (ret == AVERROR_EOF)
-            return (len > 0) ? len : AVERROR_EOF;
-        else if (ret < 0)
-            return ret;
+        } else if (ret < 1)
+            return (ret < 0 && ret != AVERROR_EOF) ? ret : len;
         if (ret) {
             fast_retries = FFMAX(fast_retries, 2);
             wait_since = 0;
diff --git a/libavformat/aviobuf.c b/libavformat/aviobuf.c
index 3e9d774a13..d1171f9082 100644
--- a/libavformat/aviobuf.c
+++ b/libavformat/aviobuf.c
@@ -565,14 +565,13 @@ static void fill_buffer(AVIOContext *s)
     if (s->read_packet)
         len = s->read_packet(s->opaque, dst, len);
     else
-        len = AVERROR_EOF;
-    if (len == AVERROR_EOF) {
+        len = 0;
+    if (len <= 0) {
         /* do not modify buffer if EOF reached so that a seek back can
            be done without rereading data */
         s->eof_reached = 1;
-    } else if (len < 0) {
-        s->eof_reached = 1;
-        s->error= len;
+        if (len < 0)
+            s->error = len;
     } else {
         s->pos += len;
         s->buf_ptr = dst;
@@ -640,16 +639,13 @@ int avio_read(AVIOContext *s, unsigned char *buf, int size)
                 // bypass the buffer and read data directly into buf
                 if(s->read_packet)
                     len = s->read_packet(s->opaque, buf, size);
-                else
-                    len = AVERROR_EOF;
-                if (len == AVERROR_EOF) {
+
+                if (len <= 0) {
                     /* do not modify buffer if EOF reached so that a seek back can
                     be done without rereading data */
                     s->eof_reached = 1;
-                    break;
-                } else if (len < 0) {
-                    s->eof_reached = 1;
-                    s->error= len;
+                    if(len<0)
+                        s->error= len;
                     break;
                 } else {
                     s->pos += len;
diff --git a/libavformat/cache.c b/libavformat/cache.c
index 66bbbf54c9..6aabca2e78 100644
--- a/libavformat/cache.c
+++ b/libavformat/cache.c
@@ -201,7 +201,7 @@ static int cache_read(URLContext *h, unsigned char *buf, int size)
     }
 
     r = ffurl_read(c->inner, buf, size);
-    if (r == AVERROR_EOF && size>0) {
+    if (r == 0 && size>0) {
         c->is_true_eof = 1;
         av_assert0(c->end >= c->logical_pos);
     }
@@ -263,7 +263,7 @@ resolve_eof:
                 if (whence == SEEK_SET)
                     size = FFMIN(sizeof(tmp), pos - c->logical_pos);
                 ret = cache_read(h, tmp, size);
-                if (ret == AVERROR_EOF && whence == SEEK_END) {
+                if (ret == 0 && whence == SEEK_END) {
                     av_assert0(c->is_true_eof);
                     goto resolve_eof;
                 }
diff --git a/libavformat/concat.c b/libavformat/concat.c
index 19c83c309a..46b520fe80 100644
--- a/libavformat/concat.c
+++ b/libavformat/concat.c
@@ -135,20 +135,19 @@ static int concat_read(URLContext *h, unsigned char *buf, int size)
 
     while (size > 0) {
         result = ffurl_read(nodes[i].uc, buf, size);
-        if (result == AVERROR_EOF) {
+        if (result < 0)
+            return total ? total : result;
+        if (!result) {
             if (i + 1 == data->length ||
                 ffurl_seek(nodes[++i].uc, 0, SEEK_SET) < 0)
                 break;
-            result = 0;
         }
-        if (result < 0)
-            return total ? total : result;
         total += result;
         buf   += result;
         size  -= result;
     }
     data->current = i;
-    return total ? total : result;
+    return total;
 }
 
 static int64_t concat_seek(URLContext *h, int64_t pos, int whence)
diff --git a/libavformat/http.c b/libavformat/http.c
index bd9148f45d..668cd51986 100644
--- a/libavformat/http.c
+++ b/libavformat/http.c
@@ -1296,11 +1296,8 @@ static int http_buf_read(URLContext *h, uint8_t *buf, int size)
                    "Chunked encoding data size: %"PRIu64"'\n",
                     s->chunksize);
 
-            if (!s->chunksize) {
-                av_log(h, AV_LOG_DEBUG, "Last chunk received, closing conn\n");
-                ffurl_closep(&s->hd);
+            if (!s->chunksize)
                 return 0;
-            }
             else if (s->chunksize == UINT64_MAX) {
                 av_log(h, AV_LOG_ERROR, "Invalid chunk size %"PRIu64"\n",
                        s->chunksize);
-- 
2.14.2


From 5a55c76be6233b7d1323a8c07835992d6f94049b Mon Sep 17 00:00:00 2001
From: wm4 <nfxjfg@googlemail.com>
Date: Fri, 27 Oct 2017 18:02:28 +0200
Subject: [PATCH 02/16] Mark as mpv modified version

---
 libavcodec/version.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/libavcodec/version.h b/libavcodec/version.h
index 6c0d7a8328..5e148023f3 100644
--- a/libavcodec/version.h
+++ b/libavcodec/version.h
@@ -41,6 +41,8 @@
 
 #define LIBAVCODEC_IDENT        "Lavc" AV_STRINGIFY(LIBAVCODEC_VERSION)
 
+#define LIBAVCODEC_MPV 1
+
 /**
  * FF_API_* defines may be placed below to indicate public API that will be
  * dropped at a future version bump. The defines themselves are not part of
-- 
2.14.2


From 20ce3a140badc5b8dc4ce5e59786092600debd03 Mon Sep 17 00:00:00 2001
From: wm4 <nfxjfg@googlemail.com>
Date: Thu, 19 Oct 2017 16:38:20 +0200
Subject: [PATCH 03/16] lavc: external hardware frame pool initialization

This adds a new API, which allows the API user to query the required
AVHWFramesContext parameters. This also reduces code duplication across
the hwaccels by introducing ff_decode_get_hw_frames_ctx(), which uses
the new API function. It takes care of initializing the hw_frames_ctx
if needed, and does additional error handling and API usage checking.

Support for VDA and Cuvid missing.

Signed-off-by: Anton Khirnov <anton@khirnov.net>
---
 doc/APIchanges              |   3 +
 libavcodec/avcodec.h        | 113 +++++++++++++++++++++++
 libavcodec/decode.c         |  82 +++++++++++++++++
 libavcodec/decode.h         |  12 +++
 libavcodec/dxva2.c          |  55 +++++------
 libavcodec/dxva2_h264.c     |   3 +
 libavcodec/dxva2_hevc.c     |   3 +
 libavcodec/dxva2_internal.h |   3 +
 libavcodec/dxva2_mpeg2.c    |   3 +
 libavcodec/dxva2_vc1.c      |   5 +
 libavcodec/dxva2_vp9.c      |   3 +
 libavcodec/vaapi_decode.c   | 216 +++++++++++++++++++++-----------------------
 libavcodec/vaapi_decode.h   |   5 +-
 libavcodec/vaapi_h264.c     |   1 +
 libavcodec/vaapi_hevc.c     |   1 +
 libavcodec/vaapi_mpeg2.c    |   1 +
 libavcodec/vaapi_mpeg4.c    |   2 +
 libavcodec/vaapi_vc1.c      |   2 +
 libavcodec/vaapi_vp9.c      |   1 +
 libavcodec/vdpau.c          |  58 ++++++------
 libavcodec/vdpau_h264.c     |   1 +
 libavcodec/vdpau_hevc.c     |   1 +
 libavcodec/vdpau_internal.h |   2 +
 libavcodec/vdpau_mpeg12.c   |   1 +
 libavcodec/vdpau_mpeg4.c    |   1 +
 libavcodec/vdpau_vc1.c      |   2 +
 libavcodec/version.h        |   2 +-
 27 files changed, 401 insertions(+), 181 deletions(-)

diff --git a/doc/APIchanges b/doc/APIchanges
index 1490d67f27..a2050775f6 100644
--- a/doc/APIchanges
+++ b/doc/APIchanges
@@ -15,6 +15,9 @@ libavutil:     2017-10-21
 
 API changes, most recent first:
 
+2017-xx-xx - xxxxxxx - lavc 58.2.100 - avcodec.h
+  Add avcodec_get_hw_frames_parameters().
+
 -------- 8< --------- FFmpeg 3.4 was cut here -------- 8< ---------
 
 2017-09-28 - b6cf66ae1c - lavc 57.106.104 - avcodec.h
diff --git a/libavcodec/avcodec.h b/libavcodec/avcodec.h
index ee7834c8a2..b28a07e6e5 100644
--- a/libavcodec/avcodec.h
+++ b/libavcodec/avcodec.h
@@ -3531,6 +3531,16 @@ typedef struct AVHWAccel {
      * Internal hwaccel capabilities.
      */
     int caps_internal;
+
+    /**
+     * Fill the given hw_frames context with current codec parameters. Called
+     * from get_format. Refer to avcodec_get_hw_frames_parameters() for
+     * details.
+     *
+     * This CAN be called before AVHWAccel.init is called, and you must assume
+     * that avctx->hwaccel_priv_data is invalid.
+     */
+    int (*frame_params)(AVCodecContext *avctx, AVBufferRef *hw_frames_ctx);
 } AVHWAccel;
 
 /**
@@ -4666,6 +4676,109 @@ int avcodec_send_frame(AVCodecContext *avctx, const AVFrame *frame);
  */
 int avcodec_receive_packet(AVCodecContext *avctx, AVPacket *avpkt);
 
+/**
+ * Create and return a AVHWFramesContext with values adequate for hardware
+ * decoding. This is meant to get called from the get_format callback, and is
+ * a helper for preparing a AVHWFramesContext for AVCodecContext.hw_frames_ctx.
+ * This API is for decoding with certain hardware acceleration modes/APIs only.
+ *
+ * The returned AVHWFramesContext is not initialized. The caller must do this
+ * with av_hwframe_ctx_init().
+ *
+ * Calling this function is not a requirement, but makes it simpler to avoid
+ * codec or hardware API specific details when manually allocating frames.
+ *
+ * Alternatively to this, an API user can set AVCodecContext.hw_device_ctx,
+ * which sets up AVCodecContext.hw_frames_ctx fully automatically, and makes
+ * it unnecessary to call this function or having to care about
+ * AVHWFramesContext initialization at all.
+ *
+ * There are a number of requirements for calling this function:
+ *
+ * - It must be called from get_format with the same avctx parameter that was
+ *   passed to get_format. Calling it outside of get_format is not allowed, and
+ *   can trigger undefined behavior.
+ * - The function is not always supported (see description of return values).
+ *   Even if this function returns successfully, hwaccel initialization could
+ *   fail later. (The degree to which implementations check whether the stream
+ *   is actually supported varies. Some do this check only after the user's
+ *   get_format callback returns.)
+ * - The hw_pix_fmt must be one of the choices suggested by get_format. If the
+ *   user decides to use a AVHWFramesContext prepared with this API function,
+ *   the user must return the same hw_pix_fmt from get_format.
+ * - The device_ref passed to this function must support the given hw_pix_fmt.
+ * - After calling this API function, it is the user's responsibility to
+ *   initialize the AVHWFramesContext (returned by the out_frames_ref parameter),
+ *   and to set AVCodecContext.hw_frames_ctx to it. If done, this must be done
+ *   before returning from get_format (this is implied by the normal
+ *   AVCodecContext.hw_frames_ctx API rules).
+ * - The AVHWFramesContext parameters may change every time time get_format is
+ *   called. Also, AVCodecContext.hw_frames_ctx is reset before get_format. So
+ *   you are inherently required to go through this process again on every
+ *   get_format call.
+ * - It is perfectly possible to call this function without actually using
+ *   the resulting AVHWFramesContext. One use-case might be trying to reuse a
+ *   previously initialized AVHWFramesContext, and calling this API function
+ *   only to test whether the required frame parameters have changed.
+ * - Fields that use dynamically allocated values of any kind must not be set
+ *   by the user unless setting them is explicitly allowed by the documentation.
+ *   If the user sets AVHWFramesContext.free and AVHWFramesContext.user_opaque,
+ *   the new free callback must call the potentially set previous free callback.
+ *   This API call may set any dynamically allocated fields, including the free
+ *   callback.
+ *
+ * The function will set at least the following fields on AVHWFramesContext
+ * (potentially more, depending on hwaccel API):
+ *
+ * - All fields set by av_hwframe_ctx_alloc().
+ * - Set the format field to hw_pix_fmt.
+ * - Set the sw_format field to the most suited and most versatile format. (An
+ *   implication is that this will prefer generic formats over opaque formats
+ *   with arbitrary restrictions, if possible.)
+ * - Set the width/height fields to the coded frame size, rounded up to the
+ *   API-specific minimum alignment.
+ * - Only _if_ the hwaccel requires a pre-allocated pool: set the initial_pool_size
+ *   field to the number of maximum reference surfaces possible with the codec,
+ *   plus 1 surface for the user to work (meaning the user can safely reference
+ *   at most 1 decoded surface at a time), plus additional buffering introduced
+ *   by frame threading. If the hwaccel does not require pre-allocation, the
+ *   field is left to 0, and the decoder will allocate new surfaces on demand
+ *   during decoding.
+ * - Possibly AVHWFramesContext.hwctx fields, depending on the underlying
+ *   hardware API.
+ *
+ * Essentially, out_frames_ref returns the same as av_hwframe_ctx_alloc(), but
+ * with basic frame parameters set.
+ *
+ * The function is stateless, and does not change the AVCodecContext or the
+ * device_ref AVHWDeviceContext.
+ *
+ * @param avctx The context which is currently calling get_format, and which
+ *              implicitly contains all state needed for filling the returned
+ *              AVHWFramesContext properly.
+ * @param device_ref A reference to the AVHWDeviceContext describing the device
+ *                   which will be used by the hardware decoder.
+ * @param hw_pix_fmt The hwaccel format you are going to return from get_format.
+ * @param out_frames_ref On success, set to a reference to an _uninitialized_
+ *                       AVHWFramesContext, created from the given device_ref.
+ *                       Fields will be set to values required for decoding.
+ *                       Not changed if an error is returned.
+ * @return zero on success, a negative value on error. The following error codes
+ *         have special semantics:
+ *      AVERROR(ENOENT): the decoder does not support this functionality. Setup
+ *                       is always manual, or it is a decoder which does not
+ *                       support setting AVCodecContext.hw_frames_ctx at all,
+ *                       or it is a software format.
+ *      AVERROR(EINVAL): it is known that hardware decoding is not supported for
+ *                       this configuration, or the device_ref is not supported
+ *                       for the hwaccel referenced by hw_pix_fmt.
+ */
+int avcodec_get_hw_frames_parameters(AVCodecContext *avctx,
+                                     AVBufferRef *device_ref,
+                                     enum AVPixelFormat hw_pix_fmt,
+                                     AVBufferRef **out_frames_ref);
+
+
 
 /**
  * @defgroup lavc_parsing Frame parsing
diff --git a/libavcodec/decode.c b/libavcodec/decode.c
index 15fc82ad39..ddb1b1f642 100644
--- a/libavcodec/decode.c
+++ b/libavcodec/decode.c
@@ -1080,6 +1080,88 @@ static AVHWAccel *find_hwaccel(enum AVCodecID codec_id,
     return NULL;
 }
 
+int ff_decode_get_hw_frames_ctx(AVCodecContext *avctx,
+                                enum AVHWDeviceType dev_type)
+{
+    AVHWDeviceContext *device_ctx;
+    AVHWFramesContext *frames_ctx;
+    int ret;
+
+    if (!avctx->hwaccel)
+        return AVERROR(ENOSYS);
+
+    if (avctx->hw_frames_ctx)
+        return 0;
+    if (!avctx->hw_device_ctx) {
+        av_log(avctx, AV_LOG_ERROR, "A hardware frames or device context is "
+                "required for hardware accelerated decoding.\n");
+        return AVERROR(EINVAL);
+    }
+
+    device_ctx = (AVHWDeviceContext *)avctx->hw_device_ctx->data;
+    if (device_ctx->type != dev_type) {
+        av_log(avctx, AV_LOG_ERROR, "Device type %s expected for hardware "
+               "decoding, but got %s.\n", av_hwdevice_get_type_name(dev_type),
+               av_hwdevice_get_type_name(device_ctx->type));
+        return AVERROR(EINVAL);
+    }
+
+    ret = avcodec_get_hw_frames_parameters(avctx,
+                                           avctx->hw_device_ctx,
+                                           avctx->hwaccel->pix_fmt,
+                                           avctx->hw_frames_ctx);
+    if (ret < 0) {
+        av_buffer_unref(&avctx->hw_frames_ctx);
+        return ret;
+    }
+
+    frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;
+
+
+    if (frames_ctx->initial_pool_size) {
+        // We guarantee 4 base work surfaces. The function above guarantees 1
+        // (the absolute minimum), so add the missing count.
+        frames_ctx->initial_pool_size += 3;
+
+        // Add an additional surface per thread is frame threading is enabled.
+        if (avctx->active_thread_type & FF_THREAD_FRAME)
+            frames_ctx->initial_pool_size += avctx->thread_count;
+    }
+
+    ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);
+    if (ret < 0) {
+        av_buffer_unref(&avctx->hw_frames_ctx);
+        return ret;
+    }
+
+    return 0;
+}
+
+int avcodec_get_hw_frames_parameters(AVCodecContext *avctx,
+                                     AVBufferRef *device_ref,
+                                     enum AVPixelFormat hw_pix_fmt,
+                                     AVBufferRef **out_frames_ref)
+{
+    AVBufferRef *frames_ref = NULL;
+    AVHWAccel *hwa = find_hwaccel(avctx->codec_id, hw_pix_fmt);
+    int ret;
+
+    if (!hwa || !hwa->frame_params)
+        return AVERROR(ENOENT);
+
+    frames_ref = av_hwframe_ctx_alloc(device_ref);
+    if (!frames_ref)
+        return AVERROR(ENOMEM);
+
+    ret = hwa->frame_params(avctx, frames_ref);
+    if (ret >= 0) {
+        *out_frames_ref = frames_ref;
+    } else {
+        av_buffer_unref(&frames_ref);
+    }
+    return ret;
+}
+
 static int setup_hwaccel(AVCodecContext *avctx,
                          const enum AVPixelFormat fmt,
                          const char *name)
diff --git a/libavcodec/decode.h b/libavcodec/decode.h
index c9630228dc..1b92e58d96 100644
--- a/libavcodec/decode.h
+++ b/libavcodec/decode.h
@@ -21,6 +21,10 @@
 #ifndef AVCODEC_DECODE_H
 #define AVCODEC_DECODE_H
 
+#include "libavutil/buffer.h"
+#include "libavutil/frame.h"
+#include "libavutil/hwcontext.h"
+
 #include "avcodec.h"
 
 /**
@@ -36,4 +40,12 @@ int ff_decode_get_packet(AVCodecContext *avctx, AVPacket *pkt);
 
 void ff_decode_bsfs_uninit(AVCodecContext *avctx);
 
+/**
+ * Make sure avctx.hw_frames_ctx is set. If it's not set, the function will
+ * try to allocate it from hw_device_ctx. If that is not possible, an error
+ * message is printed, and an error code is returned.
+ */
+int ff_decode_get_hw_frames_ctx(AVCodecContext *avctx,
+                                enum AVHWDeviceType dev_type);
+
 #endif /* AVCODEC_DECODE_H */
diff --git a/libavcodec/dxva2.c b/libavcodec/dxva2.c
index afcd361ef6..6f294703fb 100644
--- a/libavcodec/dxva2.c
+++ b/libavcodec/dxva2.c
@@ -29,6 +29,7 @@
 #include "libavutil/time.h"
 
 #include "avcodec.h"
+#include "decode.h"
 #include "dxva2_internal.h"
 
 /* define all the GUIDs used directly here,
@@ -576,14 +577,20 @@ static void ff_dxva2_unlock(AVCodecContext *avctx)
 #endif
 }
 
-// This must work before the decoder is created.
-// This somehow needs to be exported to the user.
-static void dxva_adjust_hwframes(AVCodecContext *avctx, AVHWFramesContext *frames_ctx)
+int ff_dxva2_common_frame_params(AVCodecContext *avctx,
+                                 AVBufferRef *hw_frames_ctx)
 {
-    FFDXVASharedContext *sctx = DXVA_SHARED_CONTEXT(avctx);
+    AVHWFramesContext *frames_ctx = (AVHWFramesContext *)hw_frames_ctx->data;
+    AVHWDeviceContext *device_ctx = frames_ctx->device_ctx;
     int surface_alignment, num_surfaces;
 
-    frames_ctx->format = sctx->pix_fmt;
+    if (device_ctx->type == AV_HWDEVICE_TYPE_DXVA2) {
+        frames_ctx->format = AV_PIX_FMT_DXVA2_VLD;
+    } else if (device_ctx->type == AV_HWDEVICE_TYPE_D3D11VA) {
+        frames_ctx->format = AV_PIX_FMT_D3D11;
+    } else {
+        return AVERROR(EINVAL);
+    }
 
     /* decoding MPEG-2 requires additional alignment on some Intel GPUs,
     but it causes issues for H.264 on certain AMD GPUs..... */
@@ -596,8 +603,8 @@ static void dxva_adjust_hwframes(AVCodecContext *avctx, AVHWFramesContext *frame
     else
         surface_alignment = 16;
 
-    /* 4 base work surfaces */
-    num_surfaces = 4;
+    /* 1 base work surface */
+    num_surfaces = 1;
 
     /* add surfaces based on number of possible refs */
     if (avctx->codec_id == AV_CODEC_ID_H264 || avctx->codec_id == AV_CODEC_ID_HEVC)
@@ -633,12 +640,16 @@ static void dxva_adjust_hwframes(AVCodecContext *avctx, AVHWFramesContext *frame
         frames_hwctx->BindFlags |= D3D11_BIND_DECODER;
     }
 #endif
+
+    return 0;
 }
 
 int ff_dxva2_decode_init(AVCodecContext *avctx)
 {
     FFDXVASharedContext *sctx = DXVA_SHARED_CONTEXT(avctx);
-    AVHWFramesContext *frames_ctx = NULL;
+    AVHWFramesContext *frames_ctx;
+    enum AVHWDeviceType dev_type = avctx->hwaccel->pix_fmt == AV_PIX_FMT_DXVA2_VLD
+                            ? AV_HWDEVICE_TYPE_DXVA2 : AV_HWDEVICE_TYPE_D3D11VA;
     int ret = 0;
 
     // Old API.
@@ -648,32 +659,14 @@ int ff_dxva2_decode_init(AVCodecContext *avctx)
     // (avctx->pix_fmt is not updated yet at this point)
     sctx->pix_fmt = avctx->hwaccel->pix_fmt;
 
-    if (!avctx->hw_frames_ctx && !avctx->hw_device_ctx) {
-        av_log(avctx, AV_LOG_ERROR, "Either a hw_frames_ctx or a hw_device_ctx needs to be set for hardware decoding.\n");
-        return AVERROR(EINVAL);
-    }
-
-    if (avctx->hw_frames_ctx) {
-        frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;
-    } else {
-        avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx);
-        if (!avctx->hw_frames_ctx)
-            return AVERROR(ENOMEM);
-
-        frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;
-
-        dxva_adjust_hwframes(avctx, frames_ctx);
-
-        ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);
-        if (ret < 0)
-            goto fail;
-    }
+    ret = ff_decode_get_hw_frames_ctx(avctx, dev_type);
+    if (ret < 0)
+        return ret;
 
+    frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;
     sctx->device_ctx = frames_ctx->device_ctx;
 
-    if (frames_ctx->format != sctx->pix_fmt ||
-        !((sctx->pix_fmt == AV_PIX_FMT_D3D11 && CONFIG_D3D11VA) ||
-          (sctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD && CONFIG_DXVA2))) {
+    if (frames_ctx->format != sctx->pix_fmt) {
         av_log(avctx, AV_LOG_ERROR, "Invalid pixfmt for hwaccel!\n");
         ret = AVERROR(EINVAL);
         goto fail;
diff --git a/libavcodec/dxva2_h264.c b/libavcodec/dxva2_h264.c
index e3a3f7866e..ee35b20e82 100644
--- a/libavcodec/dxva2_h264.c
+++ b/libavcodec/dxva2_h264.c
@@ -528,6 +528,7 @@ AVHWAccel ff_h264_dxva2_hwaccel = {
     .start_frame    = dxva2_h264_start_frame,
     .decode_slice   = dxva2_h264_decode_slice,
     .end_frame      = dxva2_h264_end_frame,
+    .frame_params   = ff_dxva2_common_frame_params,
     .frame_priv_data_size = sizeof(struct dxva2_picture_context),
     .priv_data_size = sizeof(FFDXVASharedContext),
 };
@@ -544,6 +545,7 @@ AVHWAccel ff_h264_d3d11va_hwaccel = {
     .start_frame    = dxva2_h264_start_frame,
     .decode_slice   = dxva2_h264_decode_slice,
     .end_frame      = dxva2_h264_end_frame,
+    .frame_params   = ff_dxva2_common_frame_params,
     .frame_priv_data_size = sizeof(struct dxva2_picture_context),
     .priv_data_size = sizeof(FFDXVASharedContext),
 };
@@ -560,6 +562,7 @@ AVHWAccel ff_h264_d3d11va2_hwaccel = {
     .start_frame    = dxva2_h264_start_frame,
     .decode_slice   = dxva2_h264_decode_slice,
     .end_frame      = dxva2_h264_end_frame,
+    .frame_params   = ff_dxva2_common_frame_params,
     .frame_priv_data_size = sizeof(struct dxva2_picture_context),
     .priv_data_size = sizeof(FFDXVASharedContext),
 };
diff --git a/libavcodec/dxva2_hevc.c b/libavcodec/dxva2_hevc.c
index 88f887a1b5..542afc383a 100644
--- a/libavcodec/dxva2_hevc.c
+++ b/libavcodec/dxva2_hevc.c
@@ -432,6 +432,7 @@ AVHWAccel ff_hevc_dxva2_hwaccel = {
     .start_frame    = dxva2_hevc_start_frame,
     .decode_slice   = dxva2_hevc_decode_slice,
     .end_frame      = dxva2_hevc_end_frame,
+    .frame_params   = ff_dxva2_common_frame_params,
     .frame_priv_data_size = sizeof(struct hevc_dxva2_picture_context),
     .priv_data_size = sizeof(FFDXVASharedContext),
 };
@@ -448,6 +449,7 @@ AVHWAccel ff_hevc_d3d11va_hwaccel = {
     .start_frame    = dxva2_hevc_start_frame,
     .decode_slice   = dxva2_hevc_decode_slice,
     .end_frame      = dxva2_hevc_end_frame,
+    .frame_params   = ff_dxva2_common_frame_params,
     .frame_priv_data_size = sizeof(struct hevc_dxva2_picture_context),
     .priv_data_size = sizeof(FFDXVASharedContext),
 };
@@ -464,6 +466,7 @@ AVHWAccel ff_hevc_d3d11va2_hwaccel = {
     .start_frame    = dxva2_hevc_start_frame,
     .decode_slice   = dxva2_hevc_decode_slice,
     .end_frame      = dxva2_hevc_end_frame,
+    .frame_params   = ff_dxva2_common_frame_params,
     .frame_priv_data_size = sizeof(struct hevc_dxva2_picture_context),
     .priv_data_size = sizeof(FFDXVASharedContext),
 };
diff --git a/libavcodec/dxva2_internal.h b/libavcodec/dxva2_internal.h
index 352a9db1ab..8bb3344090 100644
--- a/libavcodec/dxva2_internal.h
+++ b/libavcodec/dxva2_internal.h
@@ -156,6 +156,9 @@ int ff_dxva2_decode_init(AVCodecContext *avctx);
 
 int ff_dxva2_decode_uninit(AVCodecContext *avctx);
 
+int ff_dxva2_common_frame_params(AVCodecContext *avctx,
+                                 AVBufferRef *hw_frames_ctx);
+
 int ff_dxva2_is_d3d11(const AVCodecContext *avctx);
 
 #endif /* AVCODEC_DXVA2_INTERNAL_H */
diff --git a/libavcodec/dxva2_mpeg2.c b/libavcodec/dxva2_mpeg2.c
index b7c69378f0..df5fe59a7d 100644
--- a/libavcodec/dxva2_mpeg2.c
+++ b/libavcodec/dxva2_mpeg2.c
@@ -327,6 +327,7 @@ AVHWAccel ff_mpeg2_dxva2_hwaccel = {
     .start_frame    = dxva2_mpeg2_start_frame,
     .decode_slice   = dxva2_mpeg2_decode_slice,
     .end_frame      = dxva2_mpeg2_end_frame,
+    .frame_params   = ff_dxva2_common_frame_params,
     .frame_priv_data_size = sizeof(struct dxva2_picture_context),
     .priv_data_size = sizeof(FFDXVASharedContext),
 };
@@ -343,6 +344,7 @@ AVHWAccel ff_mpeg2_d3d11va_hwaccel = {
     .start_frame    = dxva2_mpeg2_start_frame,
     .decode_slice   = dxva2_mpeg2_decode_slice,
     .end_frame      = dxva2_mpeg2_end_frame,
+    .frame_params   = ff_dxva2_common_frame_params,
     .frame_priv_data_size = sizeof(struct dxva2_picture_context),
     .priv_data_size = sizeof(FFDXVASharedContext),
 };
@@ -359,6 +361,7 @@ AVHWAccel ff_mpeg2_d3d11va2_hwaccel = {
     .start_frame    = dxva2_mpeg2_start_frame,
     .decode_slice   = dxva2_mpeg2_decode_slice,
     .end_frame      = dxva2_mpeg2_end_frame,
+    .frame_params   = ff_dxva2_common_frame_params,
     .frame_priv_data_size = sizeof(struct dxva2_picture_context),
     .priv_data_size = sizeof(FFDXVASharedContext),
 };
diff --git a/libavcodec/dxva2_vc1.c b/libavcodec/dxva2_vc1.c
index e5353cdddc..f21c5d5544 100644
--- a/libavcodec/dxva2_vc1.c
+++ b/libavcodec/dxva2_vc1.c
@@ -388,6 +388,7 @@ AVHWAccel ff_wmv3_dxva2_hwaccel = {
     .start_frame    = dxva2_vc1_start_frame,
     .decode_slice   = dxva2_vc1_decode_slice,
     .end_frame      = dxva2_vc1_end_frame,
+    .frame_params   = ff_dxva2_common_frame_params,
     .frame_priv_data_size = sizeof(struct dxva2_picture_context),
     .priv_data_size = sizeof(FFDXVASharedContext),
 };
@@ -404,6 +405,7 @@ AVHWAccel ff_vc1_dxva2_hwaccel = {
     .start_frame    = dxva2_vc1_start_frame,
     .decode_slice   = dxva2_vc1_decode_slice,
     .end_frame      = dxva2_vc1_end_frame,
+    .frame_params   = ff_dxva2_common_frame_params,
     .frame_priv_data_size = sizeof(struct dxva2_picture_context),
     .priv_data_size = sizeof(FFDXVASharedContext),
 };
@@ -420,6 +422,7 @@ AVHWAccel ff_wmv3_d3d11va_hwaccel = {
     .start_frame    = dxva2_vc1_start_frame,
     .decode_slice   = dxva2_vc1_decode_slice,
     .end_frame      = dxva2_vc1_end_frame,
+    .frame_params   = ff_dxva2_common_frame_params,
     .frame_priv_data_size = sizeof(struct dxva2_picture_context),
     .priv_data_size = sizeof(FFDXVASharedContext),
 };
@@ -436,6 +439,7 @@ AVHWAccel ff_wmv3_d3d11va2_hwaccel = {
     .start_frame    = dxva2_vc1_start_frame,
     .decode_slice   = dxva2_vc1_decode_slice,
     .end_frame      = dxva2_vc1_end_frame,
+    .frame_params   = ff_dxva2_common_frame_params,
     .frame_priv_data_size = sizeof(struct dxva2_picture_context),
     .priv_data_size = sizeof(FFDXVASharedContext),
 };
@@ -452,6 +456,7 @@ AVHWAccel ff_vc1_d3d11va_hwaccel = {
     .start_frame    = dxva2_vc1_start_frame,
     .decode_slice   = dxva2_vc1_decode_slice,
     .end_frame      = dxva2_vc1_end_frame,
+    .frame_params   = ff_dxva2_common_frame_params,
     .frame_priv_data_size = sizeof(struct dxva2_picture_context),
     .priv_data_size = sizeof(FFDXVASharedContext),
 };
diff --git a/libavcodec/dxva2_vp9.c b/libavcodec/dxva2_vp9.c
index 6d87fdd9f2..a2e55f5736 100644
--- a/libavcodec/dxva2_vp9.c
+++ b/libavcodec/dxva2_vp9.c
@@ -319,6 +319,7 @@ AVHWAccel ff_vp9_dxva2_hwaccel = {
     .start_frame    = dxva2_vp9_start_frame,
     .decode_slice   = dxva2_vp9_decode_slice,
     .end_frame      = dxva2_vp9_end_frame,
+    .frame_params   = ff_dxva2_common_frame_params,
     .frame_priv_data_size = sizeof(struct vp9_dxva2_picture_context),
     .priv_data_size = sizeof(FFDXVASharedContext),
 };
@@ -335,6 +336,7 @@ AVHWAccel ff_vp9_d3d11va_hwaccel = {
     .start_frame    = dxva2_vp9_start_frame,
     .decode_slice   = dxva2_vp9_decode_slice,
     .end_frame      = dxva2_vp9_end_frame,
+    .frame_params   = ff_dxva2_common_frame_params,
     .frame_priv_data_size = sizeof(struct vp9_dxva2_picture_context),
     .priv_data_size = sizeof(FFDXVASharedContext),
 };
@@ -351,6 +353,7 @@ AVHWAccel ff_vp9_d3d11va2_hwaccel = {
     .start_frame    = dxva2_vp9_start_frame,
     .decode_slice   = dxva2_vp9_decode_slice,
     .end_frame      = dxva2_vp9_end_frame,
+    .frame_params   = ff_dxva2_common_frame_params,
     .frame_priv_data_size = sizeof(struct vp9_dxva2_picture_context),
     .priv_data_size = sizeof(FFDXVASharedContext),
 };
diff --git a/libavcodec/vaapi_decode.c b/libavcodec/vaapi_decode.c
index 27ef33837c..d467bed874 100644
--- a/libavcodec/vaapi_decode.c
+++ b/libavcodec/vaapi_decode.c
@@ -21,6 +21,7 @@
 #include "libavutil/pixdesc.h"
 
 #include "avcodec.h"
+#include "decode.h"
 #include "internal.h"
 #include "vaapi_decode.h"
 
@@ -272,10 +273,15 @@ static const struct {
 #undef MAP
 };
 
-static int vaapi_decode_make_config(AVCodecContext *avctx)
+/*
+ * Set *va_config and the frames_ref fields from the current codec parameters
+ * in avctx.
+ */
+static int vaapi_decode_make_config(AVCodecContext *avctx,
+                                    AVBufferRef *device_ref,
+                                    VAConfigID *va_config,
+                                    AVBufferRef *frames_ref)
 {
-    VAAPIDecodeContext *ctx = avctx->internal->hwaccel_priv_data;
-
     AVVAAPIHWConfig       *hwconfig    = NULL;
     AVHWFramesConstraints *constraints = NULL;
     VAStatus vas;
@@ -285,13 +291,16 @@ static int vaapi_decode_make_config(AVCodecContext *avctx)
     int profile_count, exact_match, alt_profile;
     const AVPixFmtDescriptor *sw_desc, *desc;
 
+    AVHWDeviceContext    *device = (AVHWDeviceContext*)device_ref->data;
+    AVVAAPIDeviceContext *hwctx = device->hwctx;
+
     codec_desc = avcodec_descriptor_get(avctx->codec_id);
     if (!codec_desc) {
         err = AVERROR(EINVAL);
         goto fail;
     }
 
-    profile_count = vaMaxNumProfiles(ctx->hwctx->display);
+    profile_count = vaMaxNumProfiles(hwctx->display);
     profile_list  = av_malloc_array(profile_count,
                                     sizeof(VAProfile));
     if (!profile_list) {
@@ -299,7 +308,7 @@ static int vaapi_decode_make_config(AVCodecContext *avctx)
         goto fail;
     }
 
-    vas = vaQueryConfigProfiles(ctx->hwctx->display,
+    vas = vaQueryConfigProfiles(hwctx->display,
                                 profile_list, &profile_count);
     if (vas != VA_STATUS_SUCCESS) {
         av_log(avctx, AV_LOG_ERROR, "Failed to query profiles: "
@@ -358,12 +367,9 @@ static int vaapi_decode_make_config(AVCodecContext *avctx)
         }
     }
 
-    ctx->va_profile    = profile;
-    ctx->va_entrypoint = VAEntrypointVLD;
-
-    vas = vaCreateConfig(ctx->hwctx->display, ctx->va_profile,
-                         ctx->va_entrypoint, NULL, 0,
-                         &ctx->va_config);
+    vas = vaCreateConfig(hwctx->display, profile,
+                         VAEntrypointVLD, NULL, 0,
+                         va_config);
     if (vas != VA_STATUS_SUCCESS) {
         av_log(avctx, AV_LOG_ERROR, "Failed to create decode "
                "configuration: %d (%s).\n", vas, vaErrorStr(vas));
@@ -371,20 +377,15 @@ static int vaapi_decode_make_config(AVCodecContext *avctx)
         goto fail;
     }
 
-    hwconfig = av_hwdevice_hwconfig_alloc(avctx->hw_device_ctx ?
-                                          avctx->hw_device_ctx :
-                                          ctx->frames->device_ref);
+    hwconfig = av_hwdevice_hwconfig_alloc(device_ref);
     if (!hwconfig) {
         err = AVERROR(ENOMEM);
         goto fail;
     }
-    hwconfig->config_id = ctx->va_config;
+    hwconfig->config_id = *va_config;
 
     constraints =
-        av_hwdevice_get_hwframe_constraints(avctx->hw_device_ctx ?
-                                            avctx->hw_device_ctx :
-                                            ctx->frames->device_ref,
-                                            hwconfig);
+        av_hwdevice_get_hwframe_constraints(device_ref, hwconfig);
     if (!constraints) {
         err = AVERROR(ENOMEM);
         goto fail;
@@ -410,48 +411,52 @@ static int vaapi_decode_make_config(AVCodecContext *avctx)
         goto fail;
     }
 
-    // Find the first format in the list which matches the expected
-    // bit depth and subsampling.  If none are found (this can happen
-    // when 10-bit streams are decoded to 8-bit surfaces, for example)
-    // then just take the first format on the list.
-    ctx->surface_format = constraints->valid_sw_formats[0];
-    sw_desc = av_pix_fmt_desc_get(avctx->sw_pix_fmt);
-    for (i = 0; constraints->valid_sw_formats[i] != AV_PIX_FMT_NONE; i++) {
-        desc = av_pix_fmt_desc_get(constraints->valid_sw_formats[i]);
-        if (desc->nb_components != sw_desc->nb_components ||
-            desc->log2_chroma_w != sw_desc->log2_chroma_w ||
-            desc->log2_chroma_h != sw_desc->log2_chroma_h)
-            continue;
-        for (j = 0; j < desc->nb_components; j++) {
-            if (desc->comp[j].depth != sw_desc->comp[j].depth)
-                break;
+    if (frames_ref) {
+        AVHWFramesContext *frames = (AVHWFramesContext *)frames_ref->data;
+
+        frames->format = AV_PIX_FMT_VAAPI;
+        frames->width = avctx->coded_width;
+        frames->height = avctx->coded_height;
+
+        // Find the first format in the list which matches the expected
+        // bit depth and subsampling.  If none are found (this can happen
+        // when 10-bit streams are decoded to 8-bit surfaces, for example)
+        // then just take the first format on the list.
+        frames->sw_format = constraints->valid_sw_formats[0];
+        sw_desc = av_pix_fmt_desc_get(avctx->sw_pix_fmt);
+        for (i = 0; constraints->valid_sw_formats[i] != AV_PIX_FMT_NONE; i++) {
+            desc = av_pix_fmt_desc_get(constraints->valid_sw_formats[i]);
+            if (desc->nb_components != sw_desc->nb_components ||
+                desc->log2_chroma_w != sw_desc->log2_chroma_w ||
+                desc->log2_chroma_h != sw_desc->log2_chroma_h)
+                continue;
+            for (j = 0; j < desc->nb_components; j++) {
+                if (desc->comp[j].depth != sw_desc->comp[j].depth)
+                    break;
+            }
+            if (j < desc->nb_components)
+                continue;
+            frames->sw_format = constraints->valid_sw_formats[i];
+            break;
         }
-        if (j < desc->nb_components)
-            continue;
-        ctx->surface_format = constraints->valid_sw_formats[i];
-        break;
-    }
 
-    // Start with at least four surfaces.
-    ctx->surface_count = 4;
-    // Add per-codec number of surfaces used for storing reference frames.
-    switch (avctx->codec_id) {
-    case AV_CODEC_ID_H264:
-    case AV_CODEC_ID_HEVC:
-        ctx->surface_count += 16;
-        break;
-    case AV_CODEC_ID_VP9:
-        ctx->surface_count += 8;
-        break;
-    case AV_CODEC_ID_VP8:
-        ctx->surface_count += 3;
-        break;
-    default:
-        ctx->surface_count += 2;
+        frames->initial_pool_size = 1;
+        // Add per-codec number of surfaces used for storing reference frames.
+        switch (avctx->codec_id) {
+        case AV_CODEC_ID_H264:
+        case AV_CODEC_ID_HEVC:
+            frames->initial_pool_size += 16;
+            break;
+        case AV_CODEC_ID_VP9:
+            frames->initial_pool_size += 8;
+            break;
+        case AV_CODEC_ID_VP8:
+            frames->initial_pool_size += 3;
+            break;
+        default:
+            frames->initial_pool_size += 2;
+        }
     }
-    // Add an additional surface per thread is frame threading is enabled.
-    if (avctx->active_thread_type & FF_THREAD_FRAME)
-        ctx->surface_count += avctx->thread_count;
 
     av_hwframe_constraints_free(&constraints);
     av_freep(&hwconfig);
@@ -461,14 +466,38 @@ static int vaapi_decode_make_config(AVCodecContext *avctx)
 fail:
     av_hwframe_constraints_free(&constraints);
     av_freep(&hwconfig);
-    if (ctx->va_config != VA_INVALID_ID) {
-        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);
-        ctx->va_config = VA_INVALID_ID;
+    if (*va_config != VA_INVALID_ID) {
+        vaDestroyConfig(hwctx->display, *va_config);
+        *va_config = VA_INVALID_ID;
     }
     av_freep(&profile_list);
     return err;
 }
 
+int ff_vaapi_common_frame_params(AVCodecContext *avctx,
+                                 AVBufferRef *hw_frames_ctx)
+{
+    AVHWFramesContext *hw_frames = (AVHWFramesContext *)hw_frames_ctx->data;
+    AVHWDeviceContext *device_ctx = hw_frames->device_ctx;
+    AVVAAPIDeviceContext *hwctx;
+    VAConfigID va_config = VA_INVALID_ID;
+    int err;
+
+    if (device_ctx->type != AV_HWDEVICE_TYPE_VAAPI)
+        return AVERROR(EINVAL);
+    hwctx = device_ctx->hwctx;
+
+    err = vaapi_decode_make_config(avctx, hw_frames->device_ref, &va_config,
+                                   hw_frames_ctx);
+    if (err)
+        return err;
+
+    if (va_config != VA_INVALID_ID)
+        vaDestroyConfig(hwctx->display, va_config);
+
+    return 0;
+}
+
 int ff_vaapi_decode_init(AVCodecContext *avctx)
 {
     VAAPIDecodeContext *ctx = avctx->internal->hwaccel_priv_data;
@@ -505,36 +534,8 @@ int ff_vaapi_decode_init(AVCodecContext *avctx)
         ctx->hwctx->driver_quirks =
             AV_VAAPI_DRIVER_QUIRK_RENDER_PARAM_BUFFERS;
 
-    } else
-#endif
-    if (avctx->hw_frames_ctx) {
-        // This structure has a shorter lifetime than the enclosing
-        // AVCodecContext, so we inherit the references from there
-        // and do not need to make separate ones.
-
-        ctx->frames = (AVHWFramesContext*)avctx->hw_frames_ctx->data;
-        ctx->hwfc   = ctx->frames->hwctx;
-        ctx->device = ctx->frames->device_ctx;
-        ctx->hwctx  = ctx->device->hwctx;
-
-    } else if (avctx->hw_device_ctx) {
-        ctx->device = (AVHWDeviceContext*)avctx->hw_device_ctx->data;
-        ctx->hwctx  = ctx->device->hwctx;
-
-        if (ctx->device->type != AV_HWDEVICE_TYPE_VAAPI) {
-            av_log(avctx, AV_LOG_ERROR, "Device supplied for VAAPI "
-                   "decoding must be a VAAPI device (not %d).\n",
-                   ctx->device->type);
-            err = AVERROR(EINVAL);
-            goto fail;
-        }
-
-    } else {
-        av_log(avctx, AV_LOG_ERROR, "A hardware device or frames context "
-               "is required for VAAPI decoding.\n");
-        err = AVERROR(EINVAL);
-        goto fail;
     }
+#endif
 
 #if FF_API_STRUCT_VAAPI_CONTEXT
     if (ctx->have_old_context) {
@@ -546,34 +547,19 @@ int ff_vaapi_decode_init(AVCodecContext *avctx)
     } else {
 #endif
 
-    err = vaapi_decode_make_config(avctx);
-    if (err)
+    err = ff_decode_get_hw_frames_ctx(avctx, AV_HWDEVICE_TYPE_VAAPI);
+    if (err < 0)
         goto fail;
 
-    if (!avctx->hw_frames_ctx) {
-        avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx);
-        if (!avctx->hw_frames_ctx) {
-            err = AVERROR(ENOMEM);
-            goto fail;
-        }
-        ctx->frames = (AVHWFramesContext*)avctx->hw_frames_ctx->data;
-
-        ctx->frames->format = AV_PIX_FMT_VAAPI;
-        ctx->frames->width  = avctx->coded_width;
-        ctx->frames->height = avctx->coded_height;
-
-        ctx->frames->sw_format         = ctx->surface_format;
-        ctx->frames->initial_pool_size = ctx->surface_count;
+    ctx->frames = (AVHWFramesContext*)avctx->hw_frames_ctx->data;
+    ctx->hwfc   = ctx->frames->hwctx;
+    ctx->device = ctx->frames->device_ctx;
+    ctx->hwctx  = ctx->device->hwctx;
 
-        err = av_hwframe_ctx_init(avctx->hw_frames_ctx);
-        if (err < 0) {
-            av_log(avctx, AV_LOG_ERROR, "Failed to initialise internal "
-                   "frames context: %d.\n", err);
-            goto fail;
-        }
-
-        ctx->hwfc = ctx->frames->hwctx;
-    }
+    err = vaapi_decode_make_config(avctx, ctx->frames->device_ref,
+                                   &ctx->va_config, avctx->hw_frames_ctx);
+    if (err)
+        goto fail;
 
     vas = vaCreateContext(ctx->hwctx->display, ctx->va_config,
                           avctx->coded_width, avctx->coded_height,
diff --git a/libavcodec/vaapi_decode.h b/libavcodec/vaapi_decode.h
index 550ee05432..1fcecac468 100644
--- a/libavcodec/vaapi_decode.h
+++ b/libavcodec/vaapi_decode.h
@@ -53,8 +53,6 @@ typedef struct VAAPIDecodePicture {
 } VAAPIDecodePicture;
 
 typedef struct VAAPIDecodeContext {
-    VAProfile             va_profile;
-    VAEntrypoint          va_entrypoint;
     VAConfigID            va_config;
     VAContextID           va_context;
 
@@ -98,4 +96,7 @@ int ff_vaapi_decode_cancel(AVCodecContext *avctx,
 int ff_vaapi_decode_init(AVCodecContext *avctx);
 int ff_vaapi_decode_uninit(AVCodecContext *avctx);
 
+int ff_vaapi_common_frame_params(AVCodecContext *avctx,
+                                 AVBufferRef *hw_frames_ctx);
+
 #endif /* AVCODEC_VAAPI_DECODE_H */
diff --git a/libavcodec/vaapi_h264.c b/libavcodec/vaapi_h264.c
index 30e7026ccf..c7f9d7bcb4 100644
--- a/libavcodec/vaapi_h264.c
+++ b/libavcodec/vaapi_h264.c
@@ -399,6 +399,7 @@ AVHWAccel ff_h264_vaapi_hwaccel = {
     .frame_priv_data_size = sizeof(VAAPIDecodePicture),
     .init                 = &ff_vaapi_decode_init,
     .uninit               = &ff_vaapi_decode_uninit,
+    .frame_params         = &ff_vaapi_common_frame_params,
     .priv_data_size       = sizeof(VAAPIDecodeContext),
     .caps_internal        = HWACCEL_CAP_ASYNC_SAFE,
 };
diff --git a/libavcodec/vaapi_hevc.c b/libavcodec/vaapi_hevc.c
index 69b8e478c6..718ccc92a2 100644
--- a/libavcodec/vaapi_hevc.c
+++ b/libavcodec/vaapi_hevc.c
@@ -434,6 +434,7 @@ AVHWAccel ff_hevc_vaapi_hwaccel = {
     .frame_priv_data_size = sizeof(VAAPIDecodePictureHEVC),
     .init                 = ff_vaapi_decode_init,
     .uninit               = ff_vaapi_decode_uninit,
+    .frame_params         = ff_vaapi_common_frame_params,
     .priv_data_size       = sizeof(VAAPIDecodeContext),
     .caps_internal        = HWACCEL_CAP_ASYNC_SAFE,
 };
diff --git a/libavcodec/vaapi_mpeg2.c b/libavcodec/vaapi_mpeg2.c
index 0d197c9692..fd5be8d8ae 100644
--- a/libavcodec/vaapi_mpeg2.c
+++ b/libavcodec/vaapi_mpeg2.c
@@ -183,6 +183,7 @@ AVHWAccel ff_mpeg2_vaapi_hwaccel = {
     .frame_priv_data_size = sizeof(VAAPIDecodePicture),
     .init                 = &ff_vaapi_decode_init,
     .uninit               = &ff_vaapi_decode_uninit,
+    .frame_params         = &ff_vaapi_common_frame_params,
     .priv_data_size       = sizeof(VAAPIDecodeContext),
     .caps_internal        = HWACCEL_CAP_ASYNC_SAFE,
 };
diff --git a/libavcodec/vaapi_mpeg4.c b/libavcodec/vaapi_mpeg4.c
index f8c5ddf209..3fe029186e 100644
--- a/libavcodec/vaapi_mpeg4.c
+++ b/libavcodec/vaapi_mpeg4.c
@@ -189,6 +189,7 @@ AVHWAccel ff_mpeg4_vaapi_hwaccel = {
     .frame_priv_data_size = sizeof(VAAPIDecodePicture),
     .init                 = &ff_vaapi_decode_init,
     .uninit               = &ff_vaapi_decode_uninit,
+    .frame_params         = &ff_vaapi_common_frame_params,
     .priv_data_size       = sizeof(VAAPIDecodeContext),
     .caps_internal        = HWACCEL_CAP_ASYNC_SAFE,
 };
@@ -206,6 +207,7 @@ AVHWAccel ff_h263_vaapi_hwaccel = {
     .frame_priv_data_size = sizeof(VAAPIDecodePicture),
     .init                 = &ff_vaapi_decode_init,
     .uninit               = &ff_vaapi_decode_uninit,
+    .frame_params         = &ff_vaapi_common_frame_params,
     .priv_data_size       = sizeof(VAAPIDecodeContext),
     .caps_internal        = HWACCEL_CAP_ASYNC_SAFE,
 };
diff --git a/libavcodec/vaapi_vc1.c b/libavcodec/vaapi_vc1.c
index 30c9ed3c8b..49675744cd 100644
--- a/libavcodec/vaapi_vc1.c
+++ b/libavcodec/vaapi_vc1.c
@@ -399,6 +399,7 @@ AVHWAccel ff_wmv3_vaapi_hwaccel = {
     .frame_priv_data_size = sizeof(VAAPIDecodePicture),
     .init                 = &ff_vaapi_decode_init,
     .uninit               = &ff_vaapi_decode_uninit,
+    .frame_params         = &ff_vaapi_common_frame_params,
     .priv_data_size       = sizeof(VAAPIDecodeContext),
     .caps_internal        = HWACCEL_CAP_ASYNC_SAFE,
 };
@@ -415,6 +416,7 @@ AVHWAccel ff_vc1_vaapi_hwaccel = {
     .frame_priv_data_size = sizeof(VAAPIDecodePicture),
     .init                 = &ff_vaapi_decode_init,
     .uninit               = &ff_vaapi_decode_uninit,
+    .frame_params         = &ff_vaapi_common_frame_params,
     .priv_data_size       = sizeof(VAAPIDecodeContext),
     .caps_internal        = HWACCEL_CAP_ASYNC_SAFE,
 };
diff --git a/libavcodec/vaapi_vp9.c b/libavcodec/vaapi_vp9.c
index d8ece75df4..f295dc9ebb 100644
--- a/libavcodec/vaapi_vp9.c
+++ b/libavcodec/vaapi_vp9.c
@@ -179,6 +179,7 @@ AVHWAccel ff_vp9_vaapi_hwaccel = {
     .frame_priv_data_size = sizeof(VAAPIDecodePicture),
     .init                 = ff_vaapi_decode_init,
     .uninit               = ff_vaapi_decode_uninit,
+    .frame_params         = ff_vaapi_common_frame_params,
     .priv_data_size       = sizeof(VAAPIDecodeContext),
     .caps_internal        = HWACCEL_CAP_ASYNC_SAFE,
 };
diff --git a/libavcodec/vdpau.c b/libavcodec/vdpau.c
index ee3610428f..1b2ec989cd 100644
--- a/libavcodec/vdpau.c
+++ b/libavcodec/vdpau.c
@@ -24,6 +24,7 @@
 #include <limits.h>
 
 #include "avcodec.h"
+#include "decode.h"
 #include "internal.h"
 #include "h264dec.h"
 #include "vc1.h"
@@ -110,6 +111,25 @@ int av_vdpau_get_surface_parameters(AVCodecContext *avctx,
     return 0;
 }
 
+int ff_vdpau_common_frame_params(AVCodecContext *avctx,
+                                 AVBufferRef *hw_frames_ctx)
+{
+    AVHWFramesContext *hw_frames = (AVHWFramesContext*)hw_frames_ctx->data;
+    VdpChromaType type;
+    uint32_t width;
+    uint32_t height;
+
+    if (av_vdpau_get_surface_parameters(avctx, &type, &width, &height))
+        return AVERROR(EINVAL);
+
+    hw_frames->format    = AV_PIX_FMT_VDPAU;
+    hw_frames->sw_format = avctx->sw_pix_fmt;
+    hw_frames->width     = width;
+    hw_frames->height    = height;
+
+    return 0;
+}
+
 int ff_vdpau_common_init(AVCodecContext *avctx, VdpDecoderProfile profile,
                          int level)
 {
@@ -127,6 +147,7 @@ int ff_vdpau_common_init(AVCodecContext *avctx, VdpDecoderProfile profile,
     VdpChromaType type;
     uint32_t width;
     uint32_t height;
+    int ret;
 
     vdctx->width            = UINT32_MAX;
     vdctx->height           = UINT32_MAX;
@@ -154,41 +175,14 @@ int ff_vdpau_common_init(AVCodecContext *avctx, VdpDecoderProfile profile,
             type != VDP_CHROMA_TYPE_420)
             return AVERROR(ENOSYS);
     } else {
-        AVHWFramesContext *frames_ctx = NULL;
+        AVHWFramesContext *frames_ctx;
         AVVDPAUDeviceContext *dev_ctx;
 
-        // We assume the hw_frames_ctx always survives until ff_vdpau_common_uninit
-        // is called. This holds true as the user is not allowed to touch
-        // hw_device_ctx, or hw_frames_ctx after get_format (and ff_get_format
-        // itself also uninits before unreffing hw_frames_ctx).
-        if (avctx->hw_frames_ctx) {
-            frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;
-        } else if (avctx->hw_device_ctx) {
-            int ret;
-
-            avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx);
-            if (!avctx->hw_frames_ctx)
-                return AVERROR(ENOMEM);
-
-            frames_ctx            = (AVHWFramesContext*)avctx->hw_frames_ctx->data;
-            frames_ctx->format    = AV_PIX_FMT_VDPAU;
-            frames_ctx->sw_format = avctx->sw_pix_fmt;
-            frames_ctx->width     = avctx->coded_width;
-            frames_ctx->height    = avctx->coded_height;
-
-            ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);
-            if (ret < 0) {
-                av_buffer_unref(&avctx->hw_frames_ctx);
-                return ret;
-            }
-        }
-
-        if (!frames_ctx) {
-            av_log(avctx, AV_LOG_ERROR, "A hardware frames context is "
-                   "required for VDPAU decoding.\n");
-            return AVERROR(EINVAL);
-        }
+        ret = ff_decode_get_hw_frames_ctx(avctx, AV_HWDEVICE_TYPE_VDPAU);
+        if (ret < 0)
+            return ret;
 
+        frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;
         dev_ctx = frames_ctx->device_ctx->hwctx;
 
         vdctx->device           = dev_ctx->device;
diff --git a/libavcodec/vdpau_h264.c b/libavcodec/vdpau_h264.c
index be6ba71433..70f83d76f5 100644
--- a/libavcodec/vdpau_h264.c
+++ b/libavcodec/vdpau_h264.c
@@ -273,6 +273,7 @@ AVHWAccel ff_h264_vdpau_hwaccel = {
     .frame_priv_data_size = sizeof(struct vdpau_picture_context),
     .init           = vdpau_h264_init,
     .uninit         = ff_vdpau_common_uninit,
+    .frame_params   = ff_vdpau_common_frame_params,
     .priv_data_size = sizeof(VDPAUContext),
     .caps_internal  = HWACCEL_CAP_ASYNC_SAFE,
 };
diff --git a/libavcodec/vdpau_hevc.c b/libavcodec/vdpau_hevc.c
index fcdf4b2747..70e76cfcaa 100644
--- a/libavcodec/vdpau_hevc.c
+++ b/libavcodec/vdpau_hevc.c
@@ -424,6 +424,7 @@ AVHWAccel ff_hevc_vdpau_hwaccel = {
     .frame_priv_data_size = sizeof(struct vdpau_picture_context),
     .init           = vdpau_hevc_init,
     .uninit         = ff_vdpau_common_uninit,
+    .frame_params   = ff_vdpau_common_frame_params,
     .priv_data_size = sizeof(VDPAUContext),
     .caps_internal  = HWACCEL_CAP_ASYNC_SAFE,
 };
diff --git a/libavcodec/vdpau_internal.h b/libavcodec/vdpau_internal.h
index 30d01af65d..4d63e50b16 100644
--- a/libavcodec/vdpau_internal.h
+++ b/libavcodec/vdpau_internal.h
@@ -119,5 +119,7 @@ int ff_vdpau_common_end_frame(AVCodecContext *avctx, AVFrame *frame,
 int ff_vdpau_mpeg_end_frame(AVCodecContext *avctx);
 int ff_vdpau_add_buffer(struct vdpau_picture_context *pic, const uint8_t *buf,
                         uint32_t buf_size);
+int ff_vdpau_common_frame_params(AVCodecContext *avctx,
+                                 AVBufferRef *hw_frames_ctx);
 
 #endif /* AVCODEC_VDPAU_INTERNAL_H */
diff --git a/libavcodec/vdpau_mpeg12.c b/libavcodec/vdpau_mpeg12.c
index b657007ee7..71fe889abf 100644
--- a/libavcodec/vdpau_mpeg12.c
+++ b/libavcodec/vdpau_mpeg12.c
@@ -149,6 +149,7 @@ AVHWAccel ff_mpeg2_vdpau_hwaccel = {
     .frame_priv_data_size = sizeof(struct vdpau_picture_context),
     .init           = vdpau_mpeg2_init,
     .uninit         = ff_vdpau_common_uninit,
+    .frame_params   = ff_vdpau_common_frame_params,
     .priv_data_size = sizeof(VDPAUContext),
     .caps_internal  = HWACCEL_CAP_ASYNC_SAFE,
 };
diff --git a/libavcodec/vdpau_mpeg4.c b/libavcodec/vdpau_mpeg4.c
index bbdd843a44..653ef7e7e7 100644
--- a/libavcodec/vdpau_mpeg4.c
+++ b/libavcodec/vdpau_mpeg4.c
@@ -121,6 +121,7 @@ AVHWAccel ff_mpeg4_vdpau_hwaccel = {
     .frame_priv_data_size = sizeof(struct vdpau_picture_context),
     .init           = vdpau_mpeg4_init,
     .uninit         = ff_vdpau_common_uninit,
+    .frame_params   = ff_vdpau_common_frame_params,
     .priv_data_size = sizeof(VDPAUContext),
     .caps_internal  = HWACCEL_CAP_ASYNC_SAFE,
 };
diff --git a/libavcodec/vdpau_vc1.c b/libavcodec/vdpau_vc1.c
index 665a2333f4..73d83f6577 100644
--- a/libavcodec/vdpau_vc1.c
+++ b/libavcodec/vdpau_vc1.c
@@ -147,6 +147,7 @@ AVHWAccel ff_wmv3_vdpau_hwaccel = {
     .frame_priv_data_size = sizeof(struct vdpau_picture_context),
     .init           = vdpau_vc1_init,
     .uninit         = ff_vdpau_common_uninit,
+    .frame_params   = ff_vdpau_common_frame_params,
     .priv_data_size = sizeof(VDPAUContext),
     .caps_internal  = HWACCEL_CAP_ASYNC_SAFE,
 };
@@ -163,6 +164,7 @@ AVHWAccel ff_vc1_vdpau_hwaccel = {
     .frame_priv_data_size = sizeof(struct vdpau_picture_context),
     .init           = vdpau_vc1_init,
     .uninit         = ff_vdpau_common_uninit,
+    .frame_params   = ff_vdpau_common_frame_params,
     .priv_data_size = sizeof(VDPAUContext),
     .caps_internal  = HWACCEL_CAP_ASYNC_SAFE,
 };
diff --git a/libavcodec/version.h b/libavcodec/version.h
index 5e148023f3..a152a4f1c4 100644
--- a/libavcodec/version.h
+++ b/libavcodec/version.h
@@ -28,7 +28,7 @@
 #include "libavutil/version.h"
 
 #define LIBAVCODEC_VERSION_MAJOR  58
-#define LIBAVCODEC_VERSION_MINOR   1
+#define LIBAVCODEC_VERSION_MINOR   2
 #define LIBAVCODEC_VERSION_MICRO 100
 
 #define LIBAVCODEC_VERSION_INT  AV_VERSION_INT(LIBAVCODEC_VERSION_MAJOR, \
-- 
2.14.2


From 70639ea97169205fc848be7e512f9d67b0fd3774 Mon Sep 17 00:00:00 2001
From: wm4 <nfxjfg@googlemail.com>
Date: Tue, 24 Oct 2017 00:28:03 +0200
Subject: [PATCH 04/16] lavc: fix hw_device_ctx operation

Commit b46a77f19d accidentally broke this (requested change that was
added to the patch later and which was not fully tested).

Signed-off-by: Mark Thompson <sw@jkqxz.net>
---
 libavcodec/decode.c | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/libavcodec/decode.c b/libavcodec/decode.c
index ddb1b1f642..12e0144b34 100644
--- a/libavcodec/decode.c
+++ b/libavcodec/decode.c
@@ -1109,11 +1109,9 @@ int ff_decode_get_hw_frames_ctx(AVCodecContext *avctx,
     ret = avcodec_get_hw_frames_parameters(avctx,
                                            avctx->hw_device_ctx,
                                            avctx->hwaccel->pix_fmt,
-                                           avctx->hw_frames_ctx);
-    if (ret < 0) {
-        av_buffer_unref(&avctx->hw_frames_ctx);
+                                           &avctx->hw_frames_ctx);
+    if (ret < 0)
         return ret;
-    }
 
     frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;
 
-- 
2.14.2


From 2bd9be6046665e987433da08030469b266aea291 Mon Sep 17 00:00:00 2001
From: wm4 <nfxjfg@googlemail.com>
Date: Fri, 13 Oct 2017 18:00:27 +0200
Subject: [PATCH 05/16] lavc/avrndec: remove AV_CODEC_CAP_DR1, as it's broken

In the is_mjpeg case, the user's get_buffer2 callback is not called,
thus completely breaking the API.
---
 libavcodec/avrndec.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/libavcodec/avrndec.c b/libavcodec/avrndec.c
index c37f99661b..104ff2d904 100644
--- a/libavcodec/avrndec.c
+++ b/libavcodec/avrndec.c
@@ -168,7 +168,6 @@ AVCodec ff_avrn_decoder = {
     .init           = init,
     .close          = end,
     .decode         = decode_frame,
-    .capabilities   = AV_CODEC_CAP_DR1,
     .max_lowres     = 3,
     .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
-- 
2.14.2


From f597bcbcb31e9248a4c21ecfe84d83a85be96f50 Mon Sep 17 00:00:00 2001
From: Anton Khirnov <anton@khirnov.net>
Date: Sat, 1 Jul 2017 11:32:56 +0200
Subject: [PATCH 06/16] decode: avoid leaks on failure in ff_get_buffer()

If the get_buffer() call fails, the frame might have some side data
already set. Make sure it gets freed.

CC: libav-stable@libav.org

Merges Libav commit de77671438c24ffea93398c8dc885d4dd04477de.
---
 libavcodec/decode.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/libavcodec/decode.c b/libavcodec/decode.c
index 12e0144b34..ddf64ac87c 100644
--- a/libavcodec/decode.c
+++ b/libavcodec/decode.c
@@ -1678,6 +1678,9 @@ end:
         frame->height = avctx->height;
     }
 
+    if (ret < 0)
+        av_frame_unref(frame);
+
     return ret;
 }
 
-- 
2.14.2


From d953c1295ef5b1f917f562c11a2deead7393eed4 Mon Sep 17 00:00:00 2001
From: Anton Khirnov <anton@khirnov.net>
Date: Sat, 1 Jul 2017 11:12:44 +0200
Subject: [PATCH 07/16] decode: add a method for attaching lavc-internal data
 to frames

Use the AVFrame.opaque_ref field. The original user's opaque_ref is
wrapped in the lavc struct and then unwrapped before the frame is
returned to the caller.

This new struct will be useful in the following commits.

Merges Libav commit 359a8a3e2d1194b52b6c386f94fd0929567dfb67.

This adds proper handling of draw_horiz_band over Libav. Also, the
wrapped_avframe decoder is adjusted to return the wrapped frame's
opaque_ref field to the user (which may or may not be what the user
expects).
---
 libavcodec/decode.c          | 96 +++++++++++++++++++++++++++++++++++++++++++-
 libavcodec/decode.h          | 17 ++++++++
 libavcodec/h264dec.c         |  5 ++-
 libavcodec/huffyuvdec.c      |  3 +-
 libavcodec/mpegutils.c       |  4 +-
 libavcodec/vp3.c             |  3 +-
 libavcodec/wrapped_avframe.c |  7 ++++
 7 files changed, 127 insertions(+), 8 deletions(-)

diff --git a/libavcodec/decode.c b/libavcodec/decode.c
index ddf64ac87c..36cf793b12 100644
--- a/libavcodec/decode.c
+++ b/libavcodec/decode.c
@@ -613,6 +613,26 @@ static int decode_receive_frame_internal(AVCodecContext *avctx, AVFrame *frame)
     if (ret == AVERROR_EOF)
         avci->draining_done = 1;
 
+    /* unwrap the per-frame decode data and restore the original opaque_ref*/
+    if (!ret) {
+        /* the only case where decode data is not set should be decoders
+         * that do not call ff_get_buffer() */
+        av_assert0((frame->opaque_ref && frame->opaque_ref->size == sizeof(FrameDecodeData)) ||
+                   !(avctx->codec->capabilities & AV_CODEC_CAP_DR1));
+
+        if (frame->opaque_ref) {
+            FrameDecodeData *fdd;
+            AVBufferRef *user_opaque_ref;
+
+            fdd = (FrameDecodeData*)frame->opaque_ref->data;
+
+            user_opaque_ref = fdd->user_opaque_ref;
+            fdd->user_opaque_ref = NULL;
+            av_buffer_unref(&frame->opaque_ref);
+            frame->opaque_ref = user_opaque_ref;
+        }
+    }
+
     return ret;
 }
 
@@ -1632,6 +1652,37 @@ static void validate_avframe_allocation(AVCodecContext *avctx, AVFrame *frame)
     }
 }
 
+static void decode_data_free(void *opaque, uint8_t *data)
+{
+    FrameDecodeData *fdd = (FrameDecodeData*)data;
+
+    av_buffer_unref(&fdd->user_opaque_ref);
+
+    av_freep(&fdd);
+}
+
+int ff_attach_decode_data(AVFrame *frame)
+{
+    AVBufferRef *fdd_buf;
+    FrameDecodeData *fdd;
+
+    fdd = av_mallocz(sizeof(*fdd));
+    if (!fdd)
+        return AVERROR(ENOMEM);
+
+    fdd_buf = av_buffer_create((uint8_t*)fdd, sizeof(*fdd), decode_data_free,
+                               NULL, AV_BUFFER_FLAG_READONLY);
+    if (!fdd_buf) {
+        av_freep(&fdd);
+        return AVERROR(ENOMEM);
+    }
+
+    fdd->user_opaque_ref = frame->opaque_ref;
+    frame->opaque_ref    = fdd_buf;
+
+    return 0;
+}
+
 static int get_buffer_internal(AVCodecContext *avctx, AVFrame *frame, int flags)
 {
     const AVHWAccel *hwaccel = avctx->hwaccel;
@@ -1668,8 +1719,14 @@ static int get_buffer_internal(AVCodecContext *avctx, AVFrame *frame, int flags)
         avctx->sw_pix_fmt = avctx->pix_fmt;
 
     ret = avctx->get_buffer2(avctx, frame, flags);
-    if (ret >= 0)
-        validate_avframe_allocation(avctx, frame);
+    if (ret < 0)
+        goto end;
+
+    validate_avframe_allocation(avctx, frame);
+
+    ret = ff_attach_decode_data(frame);
+    if (ret < 0)
+        goto end;
 
 end:
     if (avctx->codec_type == AVMEDIA_TYPE_VIDEO && !override_dimensions &&
@@ -1777,3 +1834,38 @@ void ff_decode_bsfs_uninit(AVCodecContext *avctx)
     av_freep(&s->bsfs);
     s->nb_bsfs = 0;
 }
+
+void ff_call_draw_horiz_band(struct AVCodecContext *s,
+                             const AVFrame *src, int offset[AV_NUM_DATA_POINTERS],
+                             int y, int type, int height)
+{
+    AVFrame *user_frame;
+
+    if (!s->draw_horiz_band)
+        return;
+
+    user_frame = av_frame_clone(src);
+    if (!user_frame) {
+        av_log(s, AV_LOG_ERROR, "draw_horiz_band() failed\n");
+        goto done;
+    }
+
+    av_buffer_unref(&user_frame->opaque_ref);
+
+    if (src->opaque_ref) {
+        FrameDecodeData *fdd = (FrameDecodeData*)src->opaque_ref->data;
+
+        if (fdd->user_opaque_ref) {
+            user_frame->opaque_ref = av_buffer_ref(fdd->user_opaque_ref);
+            if (!user_frame->opaque_ref) {
+                av_log(s, AV_LOG_ERROR, "draw_horiz_band() failed\n");
+                goto done;
+            }
+        }
+    }
+
+    s->draw_horiz_band(s, user_frame, offset, y, type, height);
+
+done:
+    av_frame_unref(user_frame);
+}
diff --git a/libavcodec/decode.h b/libavcodec/decode.h
index 1b92e58d96..800f68ccf2 100644
--- a/libavcodec/decode.h
+++ b/libavcodec/decode.h
@@ -27,6 +27,17 @@
 
 #include "avcodec.h"
 
+/**
+ * This struct stores per-frame lavc-internal data and is attached to it via
+ * opaque_ref.
+ */
+typedef struct FrameDecodeData {
+    /**
+     * The original user-set opaque_ref.
+     */
+    AVBufferRef *user_opaque_ref;
+} FrameDecodeData;
+
 /**
  * Called by decoders to get the next packet for decoding.
  *
@@ -48,4 +59,10 @@ void ff_decode_bsfs_uninit(AVCodecContext *avctx);
 int ff_decode_get_hw_frames_ctx(AVCodecContext *avctx,
                                 enum AVHWDeviceType dev_type);
 
+void ff_call_draw_horiz_band(struct AVCodecContext *s,
+                             const AVFrame *src, int offset[AV_NUM_DATA_POINTERS],
+                             int y, int type, int height);
+
+int ff_attach_decode_data(AVFrame *frame);
+
 #endif /* AVCODEC_DECODE_H */
diff --git a/libavcodec/h264dec.c b/libavcodec/h264dec.c
index 4216b66684..ed2e065319 100644
--- a/libavcodec/h264dec.c
+++ b/libavcodec/h264dec.c
@@ -39,6 +39,7 @@
 #include "cabac_functions.h"
 #include "error_resilience.h"
 #include "avcodec.h"
+#include "decode.h"
 #include "h264.h"
 #include "h264dec.h"
 #include "h2645_parse.h"
@@ -129,8 +130,8 @@ void ff_h264_draw_horiz_band(const H264Context *h, H264SliceContext *sl,
 
         emms_c();
 
-        avctx->draw_horiz_band(avctx, src, offset,
-                               y, h->picture_structure, height);
+        ff_call_draw_horiz_band(avctx, src, offset,
+                                y, h->picture_structure, height);
     }
 }
 
diff --git a/libavcodec/huffyuvdec.c b/libavcodec/huffyuvdec.c
index 979c4b9d5c..13ddad45f0 100644
--- a/libavcodec/huffyuvdec.c
+++ b/libavcodec/huffyuvdec.c
@@ -33,6 +33,7 @@
 #define UNCHECKED_BITSTREAM_READER 1
 
 #include "avcodec.h"
+#include "decode.h"
 #include "get_bits.h"
 #include "huffyuv.h"
 #include "huffyuvdsp.h"
@@ -874,7 +875,7 @@ static void draw_slice(HYuvContext *s, AVFrame *frame, int y)
         offset[i] = 0;
     emms_c();
 
-    s->avctx->draw_horiz_band(s->avctx, frame, offset, y, 3, h);
+    ff_call_draw_horiz_band(s->avctx, frame, offset, y, 3, h);
 
     s->last_slice_end = y + h;
 }
diff --git a/libavcodec/mpegutils.c b/libavcodec/mpegutils.c
index 62cc36aa6e..8221c3e0cc 100644
--- a/libavcodec/mpegutils.c
+++ b/libavcodec/mpegutils.c
@@ -25,6 +25,7 @@
 #include "libavutil/pixdesc.h"
 
 #include "avcodec.h"
+#include "decode.h"
 #include "mpegutils.h"
 
 void ff_draw_horiz_band(AVCodecContext *avctx,
@@ -74,7 +75,6 @@ void ff_draw_horiz_band(AVCodecContext *avctx,
 
         emms_c();
 
-        avctx->draw_horiz_band(avctx, src, offset,
-                               y, picture_structure, h);
+        ff_call_draw_horiz_band(avctx, src, offset, y, picture_structure, h);
     }
 }
diff --git a/libavcodec/vp3.c b/libavcodec/vp3.c
index f167acf4ee..7e4333c016 100644
--- a/libavcodec/vp3.c
+++ b/libavcodec/vp3.c
@@ -36,6 +36,7 @@
 #include "libavutil/imgutils.h"
 
 #include "avcodec.h"
+#include "decode.h"
 #include "get_bits.h"
 #include "hpeldsp.h"
 #include "internal.h"
@@ -1457,7 +1458,7 @@ static void vp3_draw_horiz_band(Vp3DecodeContext *s, int y)
         offset[i] = 0;
 
     emms_c();
-    s->avctx->draw_horiz_band(s->avctx, s->current_frame.f, offset, y, 3, h);
+    ff_call_draw_horiz_band(s->avctx, s->current_frame.f, offset, y, 3, h);
 }
 
 /**
diff --git a/libavcodec/wrapped_avframe.c b/libavcodec/wrapped_avframe.c
index 5f88a668b9..85ff32d13a 100644
--- a/libavcodec/wrapped_avframe.c
+++ b/libavcodec/wrapped_avframe.c
@@ -25,6 +25,7 @@
  */
 
 #include "avcodec.h"
+#include "decode.h"
 #include "internal.h"
 
 #include "libavutil/internal.h"
@@ -98,6 +99,12 @@ static int wrapped_avframe_decode(AVCodecContext *avctx, void *data,
 
     av_frame_move_ref(out, in);
 
+    err = ff_attach_decode_data(out);
+    if (err < 0) {
+        av_frame_unref(out);
+        return err;
+    }
+
     *got_frame = 1;
     return 0;
 }
-- 
2.14.2


From 4c9315b52fb0f04005bc25d1adcc84c0003cdd46 Mon Sep 17 00:00:00 2001
From: Anton Khirnov <anton@khirnov.net>
Date: Sat, 1 Jul 2017 12:09:58 +0200
Subject: [PATCH 08/16] decode: add a mechanism for performing delayed
 processing on the decoded frames

This will be useful in the CUVID hwaccel.

Merges Libav commit badf0951f54c1332e77455dc40398f3512540c1b.
---
 libavcodec/decode.c | 11 +++++++++++
 libavcodec/decode.h | 14 ++++++++++++++
 2 files changed, 25 insertions(+)

diff --git a/libavcodec/decode.c b/libavcodec/decode.c
index 36cf793b12..306975fa15 100644
--- a/libavcodec/decode.c
+++ b/libavcodec/decode.c
@@ -626,6 +626,14 @@ static int decode_receive_frame_internal(AVCodecContext *avctx, AVFrame *frame)
 
             fdd = (FrameDecodeData*)frame->opaque_ref->data;
 
+            if (fdd->post_process) {
+                ret = fdd->post_process(avctx, frame);
+                if (ret < 0) {
+                    av_frame_unref(frame);
+                    return ret;
+                }
+            }
+
             user_opaque_ref = fdd->user_opaque_ref;
             fdd->user_opaque_ref = NULL;
             av_buffer_unref(&frame->opaque_ref);
@@ -1658,6 +1666,9 @@ static void decode_data_free(void *opaque, uint8_t *data)
 
     av_buffer_unref(&fdd->user_opaque_ref);
 
+    if (fdd->post_process_opaque_free)
+        fdd->post_process_opaque_free(fdd->post_process_opaque);
+
     av_freep(&fdd);
 }
 
diff --git a/libavcodec/decode.h b/libavcodec/decode.h
index 800f68ccf2..129ccd43e3 100644
--- a/libavcodec/decode.h
+++ b/libavcodec/decode.h
@@ -36,6 +36,20 @@ typedef struct FrameDecodeData {
      * The original user-set opaque_ref.
      */
     AVBufferRef *user_opaque_ref;
+
+    /**
+     * The callback to perform some delayed processing on the frame right
+     * before it is returned to the caller.
+     *
+     * @note This code is called at some unspecified point after the frame is
+     * returned from the decoder's decode/receive_frame call. Therefore it cannot rely
+     * on AVCodecContext being in any specific state, so it does not get to
+     * access AVCodecContext directly at all. All the state it needs must be
+     * stored in the post_process_opaque object.
+     */
+    int (*post_process)(void *logctx, AVFrame *frame);
+    void *post_process_opaque;
+    void (*post_process_opaque_free)(void *opaque);
 } FrameDecodeData;
 
 /**
-- 
2.14.2


From 3805703be9bf7471342dcb7658f0650c5eda9fb5 Mon Sep 17 00:00:00 2001
From: Anton Khirnov <anton@khirnov.net>
Date: Sat, 1 Jul 2017 12:09:58 +0200
Subject: [PATCH 09/16] decode: add a per-frame private data for hwaccel use

This will be useful in the CUVID hwaccel. It should also eventually
replace current decoder-specific mechanisms used by various other
hwaccels.

Merges Libav commit 704311b2946d74a80f65906961cd9baaa18683a3.
---
 libavcodec/decode.c | 3 +++
 libavcodec/decode.h | 6 ++++++
 2 files changed, 9 insertions(+)

diff --git a/libavcodec/decode.c b/libavcodec/decode.c
index 306975fa15..a62713f7d9 100644
--- a/libavcodec/decode.c
+++ b/libavcodec/decode.c
@@ -1669,6 +1669,9 @@ static void decode_data_free(void *opaque, uint8_t *data)
     if (fdd->post_process_opaque_free)
         fdd->post_process_opaque_free(fdd->post_process_opaque);
 
+    if (fdd->hwaccel_priv_free)
+        fdd->hwaccel_priv_free(fdd->hwaccel_priv);
+
     av_freep(&fdd);
 }
 
diff --git a/libavcodec/decode.h b/libavcodec/decode.h
index 129ccd43e3..bba24ae4ae 100644
--- a/libavcodec/decode.h
+++ b/libavcodec/decode.h
@@ -50,6 +50,12 @@ typedef struct FrameDecodeData {
     int (*post_process)(void *logctx, AVFrame *frame);
     void *post_process_opaque;
     void (*post_process_opaque_free)(void *opaque);
+
+    /**
+     * Per-frame private data for hwaccels.
+     */
+    void *hwaccel_priv;
+    void (*hwaccel_priv_free)(void *priv);
 } FrameDecodeData;
 
 /**
-- 
2.14.2


From 97f17eaf0044f4f4bce025d30cda304eb94b3386 Mon Sep 17 00:00:00 2001
From: wm4 <nfxjfg@googlemail.com>
Date: Tue, 3 Oct 2017 13:35:08 +0200
Subject: [PATCH 10/16] avcodec/cuvid: rename cuvid.c to cuviddec.c

cuvid.c is used by Libav's CUVID hwaccel. Resolve the conflict and
avoid future merge problems by renaming our decoder.
---
 libavcodec/Makefile                | 10 +++++-----
 libavcodec/{cuvid.c => cuviddec.c} |  0
 2 files changed, 5 insertions(+), 5 deletions(-)
 rename libavcodec/{cuvid.c => cuviddec.c} (100%)

diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index e4e7a4adbf..5522e5f56c 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -333,7 +333,7 @@ OBJS-$(CONFIG_H264_DECODER)            += h264dec.o h264_cabac.o h264_cavlc.o \
                                           h264_mb.o h264_picture.o \
                                           h264_refs.o h264_sei.o \
                                           h264_slice.o h264data.o
-OBJS-$(CONFIG_H264_CUVID_DECODER)      += cuvid.o
+OBJS-$(CONFIG_H264_CUVID_DECODER)      += cuviddec.o
 OBJS-$(CONFIG_H264_MEDIACODEC_DECODER) += mediacodecdec.o
 OBJS-$(CONFIG_H264_MMAL_DECODER)       += mmaldec.o
 OBJS-$(CONFIG_H264_NVENC_ENCODER)      += nvenc_h264.o
@@ -352,7 +352,7 @@ OBJS-$(CONFIG_HAP_ENCODER)             += hapenc.o hap.o
 OBJS-$(CONFIG_HEVC_DECODER)            += hevcdec.o hevc_mvs.o \
                                           hevc_cabac.o hevc_refs.o hevcpred.o    \
                                           hevcdsp.o hevc_filter.o hevc_data.o
-OBJS-$(CONFIG_HEVC_CUVID_DECODER)      += cuvid.o
+OBJS-$(CONFIG_HEVC_CUVID_DECODER)      += cuviddec.o
 OBJS-$(CONFIG_HEVC_MEDIACODEC_DECODER) += mediacodecdec.o
 OBJS-$(CONFIG_HEVC_NVENC_ENCODER)      += nvenc_hevc.o
 OBJS-$(CONFIG_NVENC_HEVC_ENCODER)      += nvenc_hevc.o
@@ -618,7 +618,7 @@ OBJS-$(CONFIG_VC1_DECODER)             += vc1dec.o vc1_block.o vc1_loopfilter.o
                                           vc1_mc.o vc1_pred.o vc1.o vc1data.o \
                                           msmpeg4dec.o msmpeg4.o msmpeg4data.o \
                                           wmv2dsp.o wmv2data.o
-OBJS-$(CONFIG_VC1_CUVID_DECODER)       += cuvid.o
+OBJS-$(CONFIG_VC1_CUVID_DECODER)       += cuviddec.o
 OBJS-$(CONFIG_VC1_MMAL_DECODER)        += mmaldec.o
 OBJS-$(CONFIG_VC1_QSV_DECODER)         += qsvdec_other.o
 OBJS-$(CONFIG_VC1_V4L2M2M_DECODER)     += v4l2_m2m_dec.o
@@ -637,7 +637,7 @@ OBJS-$(CONFIG_VP6_DECODER)             += vp6.o vp56.o vp56data.o \
                                           vp6dsp.o vp56rac.o
 OBJS-$(CONFIG_VP7_DECODER)             += vp8.o vp56rac.o
 OBJS-$(CONFIG_VP8_DECODER)             += vp8.o vp56rac.o
-OBJS-$(CONFIG_VP8_CUVID_DECODER)       += cuvid.o
+OBJS-$(CONFIG_VP8_CUVID_DECODER)       += cuviddec.o
 OBJS-$(CONFIG_VP8_MEDIACODEC_DECODER)  += mediacodecdec.o
 OBJS-$(CONFIG_VP8_QSV_DECODER)         += qsvdec_other.o
 OBJS-$(CONFIG_VP8_RKMPP_DECODER)       += rkmppdec.o
@@ -647,7 +647,7 @@ OBJS-$(CONFIG_VP8_V4L2M2M_ENCODER)     += v4l2_m2m_enc.o
 OBJS-$(CONFIG_VP9_DECODER)             += vp9.o vp9data.o vp9dsp.o vp9lpf.o vp9recon.o \
                                           vp9block.o vp9prob.o vp9mvs.o vp56rac.o \
                                           vp9dsp_8bpp.o vp9dsp_10bpp.o vp9dsp_12bpp.o
-OBJS-$(CONFIG_VP9_CUVID_DECODER)       += cuvid.o
+OBJS-$(CONFIG_VP9_CUVID_DECODER)       += cuviddec.o
 OBJS-$(CONFIG_VP9_MEDIACODEC_DECODER)  += mediacodecdec.o
 OBJS-$(CONFIG_VP9_RKMPP_DECODER)       += rkmppdec.o
 OBJS-$(CONFIG_VP9_VAAPI_ENCODER)       += vaapi_encode_vp9.o
diff --git a/libavcodec/cuvid.c b/libavcodec/cuviddec.c
similarity index 100%
rename from libavcodec/cuvid.c
rename to libavcodec/cuviddec.c
-- 
2.14.2


From b1a6f6783d492657ffa807abd8972aecf63dbdc9 Mon Sep 17 00:00:00 2001
From: wm4 <nfxjfg@googlemail.com>
Date: Tue, 3 Oct 2017 15:04:45 +0200
Subject: [PATCH 11/16] avcodec: allow multiple hwaccels for the same
 codec/pixfmt

Currently, AVHWAccels are looked up using a (codec_id, pixfmt) tuple.
This means it's impossible to have 2 decoders for the same codec and
using the same opaque hardware pixel format.

This breaks merging Libav's CUVID hwaccel. FFmpeg has its own CUVID
support, but it's a full stream decoder, using NVIDIA's codec parser.
The Libav one is a true hwaccel, which is based on the builtin software
decoders.

Fix this by introducing another field to disambiguate AVHWAccels, and
use it for our CUVID decoders. FF_CODEC_CAP_HWACCEL_REQUIRE_CLASS makes
this mechanism backwards compatible and optional.

Note: this can be reverted later when the AVHWAccel infrastructure gets
overhauled.
---
 libavcodec/avcodec.h  |  5 +++++
 libavcodec/cuviddec.c |  2 ++
 libavcodec/decode.c   | 14 +++++++++-----
 libavcodec/internal.h |  5 +++++
 4 files changed, 21 insertions(+), 5 deletions(-)

diff --git a/libavcodec/avcodec.h b/libavcodec/avcodec.h
index b28a07e6e5..8f41c061cf 100644
--- a/libavcodec/avcodec.h
+++ b/libavcodec/avcodec.h
@@ -3541,6 +3541,11 @@ typedef struct AVHWAccel {
      * that avctx->hwaccel_priv_data is invalid.
      */
     int (*frame_params)(AVCodecContext *avctx, AVBufferRef *hw_frames_ctx);
+
+    /**
+     * Some hwaccels are ambiguous if only
+     */
+    const AVClass *decoder_class;
 } AVHWAccel;
 
 /**
diff --git a/libavcodec/cuviddec.c b/libavcodec/cuviddec.c
index 2ba8e00c6a..6370348639 100644
--- a/libavcodec/cuviddec.c
+++ b/libavcodec/cuviddec.c
@@ -1106,6 +1106,7 @@ static const AVOption options[] = {
         .type           = AVMEDIA_TYPE_VIDEO, \
         .id             = AV_CODEC_ID_##X, \
         .pix_fmt        = AV_PIX_FMT_CUDA, \
+        .decoder_class  = &x##_cuvid_class, \
     }; \
     AVCodec ff_##x##_cuvid_decoder = { \
         .name           = #x "_cuvid", \
@@ -1120,6 +1121,7 @@ static const AVOption options[] = {
         .receive_frame  = cuvid_output_frame, \
         .flush          = cuvid_flush, \
         .capabilities   = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING, \
+        .caps_internal  = FF_CODEC_CAP_HWACCEL_REQUIRE_CLASS, \
         .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_CUDA, \
                                                         AV_PIX_FMT_NV12, \
                                                         AV_PIX_FMT_P010, \
diff --git a/libavcodec/decode.c b/libavcodec/decode.c
index a62713f7d9..d7cff3e5df 100644
--- a/libavcodec/decode.c
+++ b/libavcodec/decode.c
@@ -1096,15 +1096,19 @@ enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s, const en
     return fmt[0];
 }
 
-static AVHWAccel *find_hwaccel(enum AVCodecID codec_id,
+static AVHWAccel *find_hwaccel(AVCodecContext *avctx,
                                enum AVPixelFormat pix_fmt)
 {
     AVHWAccel *hwaccel = NULL;
+    const AVClass *av_class =
+        (avctx->codec->caps_internal & FF_CODEC_CAP_HWACCEL_REQUIRE_CLASS)
+        ? avctx->codec->priv_class : NULL;
 
-    while ((hwaccel = av_hwaccel_next(hwaccel)))
-        if (hwaccel->id == codec_id
+    while ((hwaccel = av_hwaccel_next(hwaccel))) {
+        if (hwaccel->decoder_class == av_class && hwaccel->id == avctx->codec_id
             && hwaccel->pix_fmt == pix_fmt)
             return hwaccel;
+    }
     return NULL;
 }
 
@@ -1169,7 +1173,7 @@ int avcodec_get_hw_frames_parameters(AVCodecContext *avctx,
                                      AVBufferRef **out_frames_ref)
 {
     AVBufferRef *frames_ref = NULL;
-    AVHWAccel *hwa = find_hwaccel(avctx->codec_id, hw_pix_fmt);
+    AVHWAccel *hwa = find_hwaccel(avctx, hw_pix_fmt);
     int ret;
 
     if (!hwa || !hwa->frame_params)
@@ -1192,7 +1196,7 @@ static int setup_hwaccel(AVCodecContext *avctx,
                          const enum AVPixelFormat fmt,
                          const char *name)
 {
-    AVHWAccel *hwa = find_hwaccel(avctx->codec_id, fmt);
+    AVHWAccel *hwa = find_hwaccel(avctx, fmt);
     int ret        = 0;
 
     if (!hwa) {
diff --git a/libavcodec/internal.h b/libavcodec/internal.h
index 7748f09f54..948d5461c1 100644
--- a/libavcodec/internal.h
+++ b/libavcodec/internal.h
@@ -69,6 +69,11 @@
  */
 #define FF_CODEC_CAP_SLICE_THREAD_HAS_MF    (1 << 5)
 
+/**
+ * Allow only AVHWAccels which have a matching decoder_class field.
+ */
+#define FF_CODEC_CAP_HWACCEL_REQUIRE_CLASS  (1 << 6)
+
 #ifdef TRACE
 #   define ff_tlog(ctx, ...) av_log(ctx, AV_LOG_TRACE, __VA_ARGS__)
 #else
-- 
2.14.2


From e1a7369daecc7bd3eef2717703778d86661dca13 Mon Sep 17 00:00:00 2001
From: Anton Khirnov <anton@khirnov.net>
Date: Sat, 11 Feb 2017 16:49:34 +0100
Subject: [PATCH 12/16] h264dec: add a CUVID hwaccel

Some parts of the code are based on a patch by
Timo Rothenpieler <timo@rothenpieler.org>

Merges Libav commit b9129ec4668c511e0a79e25c6f25d748cee172c9.

As a complication, all the names conflict. Add a _hwaccel suffix to the
merged code where needed.

This commit also changes the Libav code to dynamic loading of the
cuda/cuvid libraries. (I wouldn't be able to test with the fixed SDK
anyway, because installing the CUDA SDK on Linux is hell.)

Signed-off-by: wm4 <nfxjfg@googlemail.com>
---
 Changelog               |   1 +
 configure               |  10 +-
 fftools/ffmpeg.h        |   1 +
 fftools/ffmpeg_opt.c    |   4 +
 libavcodec/Makefile     |   2 +
 libavcodec/allcodecs.c  |   1 +
 libavcodec/avcodec.h    |   4 +-
 libavcodec/cuvid.c      | 431 ++++++++++++++++++++++++++++++++++++++++++++++++
 libavcodec/cuvid.h      |  62 +++++++
 libavcodec/cuvid_h264.c | 176 ++++++++++++++++++++
 libavcodec/h264_slice.c |   6 +-
 11 files changed, 694 insertions(+), 4 deletions(-)
 create mode 100644 libavcodec/cuvid.c
 create mode 100644 libavcodec/cuvid.h
 create mode 100644 libavcodec/cuvid_h264.c

diff --git a/Changelog b/Changelog
index 8c45b2946d..2fda8d8263 100644
--- a/Changelog
+++ b/Changelog
@@ -97,6 +97,7 @@ version 3.3:
 - Removed asyncts filter (use af_aresample instead)
 - Intel QSV-accelerated VP8 video decoding
 - VAAPI-accelerated deinterlacing
+- NVIDIA CUVID-accelerated H.264 hwaccel decoding
 
 
 version 3.2:
diff --git a/configure b/configure
index 2f259996ae..0f6f612bd6 100755
--- a/configure
+++ b/configure
@@ -307,6 +307,7 @@ External library support:
   --disable-cuda           disable dynamically linked Nvidia CUDA code [autodetect]
   --enable-cuda-sdk        enable CUDA features that require the CUDA SDK [no]
   --disable-cuvid          disable Nvidia CUVID support [autodetect]
+  --disable-cuvid-hwaccel  Nvidia CUVID video decode acceleration (via hwaccel) [autodetect]
   --disable-d3d11va        disable Microsoft Direct3D 11 video acceleration code [autodetect]
   --disable-dxva2          disable Microsoft DirectX 9 video acceleration code [autodetect]
   --enable-libdrm          enable DRM code (Linux) [no]
@@ -1645,6 +1646,7 @@ HWACCEL_AUTODETECT_LIBRARY_LIST="
     crystalhd
     cuda
     cuvid
+    cuvid_hwaccel
     d3d11va
     dxva2
     nvenc
@@ -2664,6 +2666,8 @@ h263_videotoolbox_hwaccel_deps="videotoolbox"
 h263_videotoolbox_hwaccel_select="h263_decoder"
 h264_cuvid_hwaccel_deps="cuda cuvid"
 h264_cuvid_hwaccel_select="h264_cuvid_decoder"
+h264_cuvid_hwaccel_hwaccel_deps="cuda cuvid_hwaccel"
+h264_cuvid_hwaccel_hwaccel_select="h264_decoder"
 h264_d3d11va_hwaccel_deps="d3d11va"
 h264_d3d11va_hwaccel_select="h264_decoder"
 h264_d3d11va2_hwaccel_deps="d3d11va"
@@ -5944,6 +5948,8 @@ done
 enabled cuda_sdk          && require cuda_sdk cuda.h cuCtxCreate -lcuda
 enabled cuvid             && { enabled cuda ||
                                die "ERROR: CUVID requires CUDA"; }
+enabled cuvid_hwaccel     && { enabled cuda ||
+                               die "ERROR: CUVID hwaccel requires CUDA"; }
 enabled chromaprint       && require chromaprint chromaprint.h chromaprint_get_version -lchromaprint
 enabled decklink          && { require_header DeckLinkAPI.h &&
                                { check_cpp_condition DeckLinkAPIVersion.h "BLACKMAGIC_DECKLINK_API_VERSION >= 0x0a060100" || die "ERROR: Decklink API version must be >= 10.6.1."; } }
@@ -6299,11 +6305,11 @@ if enabled x86; then
         mingw32*|mingw64*|win32|win64|linux|cygwin*)
             ;;
         *)
-            disable cuda cuvid nvenc
+            disable cuda cuvid cuvid_hwaccel nvenc
             ;;
     esac
 else
-    disable cuda cuvid nvenc
+    disable cuda cuvid cuvid_hwaccel nvenc
 fi
 
 enabled nvenc &&
diff --git a/fftools/ffmpeg.h b/fftools/ffmpeg.h
index 50fc8d5767..51f21ee802 100644
--- a/fftools/ffmpeg.h
+++ b/fftools/ffmpeg.h
@@ -68,6 +68,7 @@ enum HWAccelID {
     HWACCEL_VAAPI,
     HWACCEL_CUVID,
     HWACCEL_D3D11VA,
+    HWACCEL_CUVID_HWACCEL,
 };
 
 typedef struct HWAccel {
diff --git a/fftools/ffmpeg_opt.c b/fftools/ffmpeg_opt.c
index 3a947d8686..96ffde3f3f 100644
--- a/fftools/ffmpeg_opt.c
+++ b/fftools/ffmpeg_opt.c
@@ -93,6 +93,10 @@ const HWAccel hwaccels[] = {
 #if CONFIG_CUVID
     { "cuvid", cuvid_init, HWACCEL_CUVID, AV_PIX_FMT_CUDA,
       AV_HWDEVICE_TYPE_NONE },
+#endif
+#if CONFIG_CUVID_HWACCEL
+    { "cuvid_hwaccel", hwaccel_decode_init, HWACCEL_CUVID_HWACCEL, AV_PIX_FMT_CUDA,
+       AV_HWDEVICE_TYPE_CUDA },
 #endif
     { 0 },
 };
diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index 5522e5f56c..17019748c4 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -822,6 +822,7 @@ OBJS-$(CONFIG_ADPCM_YAMAHA_DECODER)       += adpcm.o adpcm_data.o
 OBJS-$(CONFIG_ADPCM_YAMAHA_ENCODER)       += adpcmenc.o adpcm_data.o
 
 # hardware accelerators
+OBJS-$(CONFIG_CUVID_HWACCEL)              += cuvid.o
 OBJS-$(CONFIG_D3D11VA)                    += dxva2.o
 OBJS-$(CONFIG_DXVA2)                      += dxva2.o
 OBJS-$(CONFIG_VAAPI)                      += vaapi_decode.o
@@ -830,6 +831,7 @@ OBJS-$(CONFIG_VDPAU)                      += vdpau.o
 
 OBJS-$(CONFIG_H263_VAAPI_HWACCEL)         += vaapi_mpeg4.o
 OBJS-$(CONFIG_H263_VIDEOTOOLBOX_HWACCEL)  += videotoolbox.o
+OBJS-$(CONFIG_H264_CUVID_HWACCEL_HWACCEL) += cuvid_h264.o
 OBJS-$(CONFIG_H264_D3D11VA_HWACCEL)       += dxva2_h264.o
 OBJS-$(CONFIG_H264_DXVA2_HWACCEL)         += dxva2_h264.o
 OBJS-$(CONFIG_H264_QSV_HWACCEL)           += qsvdec_h2645.o
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index 98655ddd7c..880950f039 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -65,6 +65,7 @@ static void register_all(void)
     REGISTER_HWACCEL(H263_VAAPI,        h263_vaapi);
     REGISTER_HWACCEL(H263_VIDEOTOOLBOX, h263_videotoolbox);
     REGISTER_HWACCEL(H264_CUVID,        h264_cuvid);
+    REGISTER_HWACCEL(H264_CUVID,        h264_cuvid_hwaccel);
     REGISTER_HWACCEL(H264_D3D11VA,      h264_d3d11va);
     REGISTER_HWACCEL(H264_D3D11VA2,     h264_d3d11va2);
     REGISTER_HWACCEL(H264_DXVA2,        h264_dxva2);
diff --git a/libavcodec/avcodec.h b/libavcodec/avcodec.h
index 8f41c061cf..15e1197fed 100644
--- a/libavcodec/avcodec.h
+++ b/libavcodec/avcodec.h
@@ -3543,7 +3543,9 @@ typedef struct AVHWAccel {
     int (*frame_params)(AVCodecContext *avctx, AVBufferRef *hw_frames_ctx);
 
     /**
-     * Some hwaccels are ambiguous if only
+     * Some hwaccels are ambiguous if only the id and pix_fmt fields are used.
+     * If non-NULL, the associated AVCodec must have
+     * FF_CODEC_CAP_HWACCEL_REQUIRE_CLASS set.
      */
     const AVClass *decoder_class;
 } AVHWAccel;
diff --git a/libavcodec/cuvid.c b/libavcodec/cuvid.c
new file mode 100644
index 0000000000..c90ca38a84
--- /dev/null
+++ b/libavcodec/cuvid.c
@@ -0,0 +1,431 @@
+/*
+ * HW decode acceleration through CUVID
+ *
+ * Copyright (c) 2016 Anton Khirnov
+ *
+ * This file is part of Libav.
+ *
+ * Libav is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * Libav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with Libav; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "config.h"
+
+#include "libavutil/common.h"
+#include "libavutil/error.h"
+#include "libavutil/hwcontext.h"
+#include "libavutil/hwcontext_cuda_internal.h"
+#include "libavutil/pixdesc.h"
+#include "libavutil/pixfmt.h"
+
+#include "avcodec.h"
+#include "decode.h"
+#include "cuvid.h"
+#include "internal.h"
+
+typedef struct CUVIDDecoder {
+    CUvideodecoder decoder;
+
+    AVBufferRef *hw_device_ref;
+    CUcontext    cuda_ctx;
+
+    CudaFunctions *cudl;
+    CuvidFunctions *cvdl;
+} CUVIDDecoder;
+
+typedef struct CUVIDFramePool {
+    unsigned int dpb_size;
+    unsigned int nb_allocated;
+} CUVIDFramePool;
+
+static int map_avcodec_id(enum AVCodecID id)
+{
+    switch (id) {
+    case AV_CODEC_ID_H264: return cudaVideoCodec_H264;
+    }
+    return -1;
+}
+
+static int map_chroma_format(enum AVPixelFormat pix_fmt)
+{
+    int shift_h = 0, shift_v = 0;
+
+    av_pix_fmt_get_chroma_sub_sample(pix_fmt, &shift_h, &shift_v);
+
+    if (shift_h == 1 && shift_v == 1)
+        return cudaVideoChromaFormat_420;
+    else if (shift_h == 1 && shift_v == 0)
+        return cudaVideoChromaFormat_422;
+    else if (shift_h == 0 && shift_v == 0)
+        return cudaVideoChromaFormat_444;
+
+    return -1;
+}
+
+static void cuvid_decoder_free(void *opaque, uint8_t *data)
+{
+    CUVIDDecoder *decoder = (CUVIDDecoder*)data;
+
+    if (decoder->decoder)
+        decoder->cvdl->cuvidDestroyDecoder(decoder->decoder);
+
+    av_buffer_unref(&decoder->hw_device_ref);
+
+    cuvid_free_functions(&decoder->cvdl);
+
+    av_freep(&decoder);
+}
+
+static int cuvid_decoder_create(AVBufferRef **out, AVBufferRef *hw_device_ref,
+                                CUVIDDECODECREATEINFO *params, void *logctx)
+{
+    AVHWDeviceContext  *hw_device_ctx = (AVHWDeviceContext*)hw_device_ref->data;
+    AVCUDADeviceContext *device_hwctx = hw_device_ctx->hwctx;
+
+    AVBufferRef *decoder_ref;
+    CUVIDDecoder *decoder;
+
+    CUcontext dummy;
+    CUresult err;
+    int ret;
+
+    decoder = av_mallocz(sizeof(*decoder));
+    if (!decoder)
+        return AVERROR(ENOMEM);
+
+    decoder_ref = av_buffer_create((uint8_t*)decoder, sizeof(*decoder),
+                                   cuvid_decoder_free, NULL, AV_BUFFER_FLAG_READONLY);
+    if (!decoder_ref) {
+        av_freep(&decoder);
+        return AVERROR(ENOMEM);
+    }
+
+    decoder->hw_device_ref = av_buffer_ref(hw_device_ref);
+    if (!decoder->hw_device_ref) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+    decoder->cuda_ctx = device_hwctx->cuda_ctx;
+    decoder->cudl = device_hwctx->internal->cuda_dl;
+
+    ret = cuvid_load_functions(&decoder->cvdl);
+    if (ret < 0) {
+        av_log(logctx, AV_LOG_ERROR, "Failed loading nvcuvid.\n");
+        goto fail;
+    }
+
+    err = decoder->cudl->cuCtxPushCurrent(decoder->cuda_ctx);
+    if (err != CUDA_SUCCESS) {
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    err = decoder->cvdl->cuvidCreateDecoder(&decoder->decoder, params);
+
+    decoder->cudl->cuCtxPopCurrent(&dummy);
+
+    if (err != CUDA_SUCCESS) {
+        av_log(logctx, AV_LOG_ERROR, "Error creating a CUVID decoder: %d\n", err);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    *out = decoder_ref;
+
+    return 0;
+fail:
+    av_buffer_unref(&decoder_ref);
+    return ret;
+}
+
+static AVBufferRef *cuvid_decoder_frame_alloc(void *opaque, int size)
+{
+    CUVIDFramePool *pool = opaque;
+    AVBufferRef *ret;
+
+    if (pool->nb_allocated >= pool->dpb_size)
+        return NULL;
+
+    ret = av_buffer_alloc(sizeof(unsigned int));
+    if (!ret)
+        return NULL;
+
+    *(unsigned int*)ret->data = pool->nb_allocated++;
+
+    return ret;
+}
+
+int ff_cuvid_decode_uninit(AVCodecContext *avctx)
+{
+    CUVIDContext *ctx = avctx->internal->hwaccel_priv_data;
+
+    av_freep(&ctx->bitstream);
+    ctx->bitstream_len       = 0;
+    ctx->bitstream_allocated = 0;
+
+    av_freep(&ctx->slice_offsets);
+    ctx->nb_slices               = 0;
+    ctx->slice_offsets_allocated = 0;
+
+    av_buffer_unref(&ctx->decoder_ref);
+    av_buffer_pool_uninit(&ctx->decoder_pool);
+
+    return 0;
+}
+
+int ff_cuvid_decode_init(AVCodecContext *avctx, unsigned int dpb_size)
+{
+    CUVIDContext *ctx = avctx->internal->hwaccel_priv_data;
+
+    CUVIDFramePool      *pool;
+    AVHWFramesContext   *frames_ctx;
+    const AVPixFmtDescriptor *sw_desc;
+
+    CUVIDDECODECREATEINFO params = { 0 };
+
+    int cuvid_codec_type, cuvid_chroma_format;
+    int ret = 0;
+
+    sw_desc = av_pix_fmt_desc_get(avctx->sw_pix_fmt);
+    if (!sw_desc)
+        return AVERROR_BUG;
+
+    cuvid_codec_type = map_avcodec_id(avctx->codec_id);
+    if (cuvid_codec_type < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Unsupported codec ID\n");
+        return AVERROR_BUG;
+    }
+
+    cuvid_chroma_format = map_chroma_format(avctx->sw_pix_fmt);
+    if (cuvid_chroma_format < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Unsupported chroma format\n");
+        return AVERROR(ENOSYS);
+    }
+
+    if (avctx->thread_type & FF_THREAD_FRAME)
+        dpb_size += avctx->thread_count;
+
+    if (!avctx->hw_frames_ctx) {
+        AVHWFramesContext *frames_ctx;
+
+        if (!avctx->hw_device_ctx) {
+            av_log(avctx, AV_LOG_ERROR, "A hardware device or frames context "
+                   "is required for CUVID decoding.\n");
+            return AVERROR(EINVAL);
+        }
+
+        avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx);
+        if (!avctx->hw_frames_ctx)
+            return AVERROR(ENOMEM);
+        frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;
+
+        frames_ctx->format            = AV_PIX_FMT_CUDA;
+        frames_ctx->width             = avctx->coded_width;
+        frames_ctx->height            = avctx->coded_height;
+        frames_ctx->sw_format         = AV_PIX_FMT_NV12;
+        frames_ctx->sw_format         = sw_desc->comp[0].depth > 8 ?
+                                        AV_PIX_FMT_P010 : AV_PIX_FMT_NV12;
+        frames_ctx->initial_pool_size = dpb_size;
+
+        ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);
+        if (ret < 0) {
+            av_log(avctx, AV_LOG_ERROR, "Error initializing internal frames context\n");
+            return ret;
+        }
+    }
+    frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;
+
+    params.ulWidth             = avctx->coded_width;
+    params.ulHeight            = avctx->coded_height;
+    params.ulTargetWidth       = avctx->coded_width;
+    params.ulTargetHeight      = avctx->coded_height;
+    params.bitDepthMinus8      = sw_desc->comp[0].depth - 8;
+    params.OutputFormat        = params.bitDepthMinus8 ?
+                                 cudaVideoSurfaceFormat_P016 : cudaVideoSurfaceFormat_NV12;
+    params.CodecType           = cuvid_codec_type;
+    params.ChromaFormat        = cuvid_chroma_format;
+    params.ulNumDecodeSurfaces = dpb_size;
+    params.ulNumOutputSurfaces = 1;
+
+    ret = cuvid_decoder_create(&ctx->decoder_ref, frames_ctx->device_ref, &params, avctx);
+    if (ret < 0)
+        return ret;
+
+    pool = av_mallocz(sizeof(*pool));
+    if (!pool) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+    pool->dpb_size = dpb_size;
+
+    ctx->decoder_pool = av_buffer_pool_init2(sizeof(int), pool,
+                                             cuvid_decoder_frame_alloc, av_free);
+    if (!ctx->decoder_pool) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    return 0;
+fail:
+    ff_cuvid_decode_uninit(avctx);
+    return ret;
+}
+
+static void cuvid_fdd_priv_free(void *priv)
+{
+    CUVIDFrame *cf = priv;
+
+    if (!cf)
+        return;
+
+    av_buffer_unref(&cf->idx_ref);
+    av_buffer_unref(&cf->decoder_ref);
+
+    av_freep(&priv);
+}
+
+static int cuvid_retrieve_data(void *logctx, AVFrame *frame)
+{
+    FrameDecodeData  *fdd = (FrameDecodeData*)frame->opaque_ref->data;
+    CUVIDFrame        *cf = (CUVIDFrame*)fdd->hwaccel_priv;
+    CUVIDDecoder *decoder = (CUVIDDecoder*)cf->decoder_ref->data;
+
+    CUVIDPROCPARAMS vpp = { .progressive_frame = 1 };
+
+    CUresult err;
+    CUcontext dummy;
+    CUdeviceptr devptr;
+
+    unsigned int pitch, i;
+    unsigned int offset = 0;
+    int ret = 0;
+
+    err = decoder->cudl->cuCtxPushCurrent(decoder->cuda_ctx);
+    if (err != CUDA_SUCCESS)
+        return AVERROR_UNKNOWN;
+
+    err = decoder->cvdl->cuvidMapVideoFrame(decoder->decoder, cf->idx, &devptr,
+                                            &pitch, &vpp);
+    if (err != CUDA_SUCCESS) {
+        av_log(logctx, AV_LOG_ERROR, "Error mapping a picture with CUVID: %d\n",
+               err);
+        ret = AVERROR_UNKNOWN;
+        goto finish;
+    }
+
+    for (i = 0; frame->data[i]; i++) {
+        CUDA_MEMCPY2D cpy = {
+            .srcMemoryType = CU_MEMORYTYPE_DEVICE,
+            .dstMemoryType = CU_MEMORYTYPE_DEVICE,
+            .srcDevice     = devptr,
+            .dstDevice     = (CUdeviceptr)frame->data[i],
+            .srcPitch      = pitch,
+            .dstPitch      = frame->linesize[i],
+            .srcY          = offset,
+            .WidthInBytes  = FFMIN(pitch, frame->linesize[i]),
+            .Height        = frame->height >> (i ? 1 : 0),
+        };
+
+        err = decoder->cudl->cuMemcpy2D(&cpy);
+        if (err != CUDA_SUCCESS) {
+            av_log(logctx, AV_LOG_ERROR, "Error copying decoded frame: %d\n",
+                   err);
+            ret = AVERROR_UNKNOWN;
+            goto copy_fail;
+        }
+
+        offset += cpy.Height;
+    }
+
+copy_fail:
+    decoder->cvdl->cuvidUnmapVideoFrame(decoder->decoder, devptr);
+
+finish:
+    decoder->cudl->cuCtxPopCurrent(&dummy);
+    return ret;
+}
+
+int ff_cuvid_start_frame(AVCodecContext *avctx, AVFrame *frame)
+{
+    CUVIDContext *ctx = avctx->internal->hwaccel_priv_data;
+    FrameDecodeData *fdd = (FrameDecodeData*)frame->opaque_ref->data;
+    CUVIDFrame *cf = NULL;
+    int ret;
+
+    ctx->bitstream_len = 0;
+    ctx->nb_slices     = 0;
+
+    if (fdd->hwaccel_priv)
+        return 0;
+
+    cf = av_mallocz(sizeof(*cf));
+    if (!cf)
+        return AVERROR(ENOMEM);
+
+    cf->decoder_ref = av_buffer_ref(ctx->decoder_ref);
+    if (!cf->decoder_ref)
+        goto fail;
+
+    cf->idx_ref = av_buffer_pool_get(ctx->decoder_pool);
+    if (!cf->idx_ref) {
+        av_log(avctx, AV_LOG_ERROR, "No decoder surfaces left\n");
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+    cf->idx = *(unsigned int*)cf->idx_ref->data;
+
+    fdd->hwaccel_priv      = cf;
+    fdd->hwaccel_priv_free = cuvid_fdd_priv_free;
+    fdd->post_process      = cuvid_retrieve_data;
+
+    return 0;
+fail:
+    cuvid_fdd_priv_free(cf);
+    return ret;
+
+}
+
+int ff_cuvid_end_frame(AVCodecContext *avctx)
+{
+    CUVIDContext     *ctx = avctx->internal->hwaccel_priv_data;
+    CUVIDDecoder *decoder = (CUVIDDecoder*)ctx->decoder_ref->data;
+    CUVIDPICPARAMS    *pp = &ctx->pic_params;
+
+    CUresult err;
+    CUcontext dummy;
+
+    int ret = 0;
+
+    pp->nBitstreamDataLen = ctx->bitstream_len;
+    pp->pBitstreamData    = ctx->bitstream;
+    pp->nNumSlices        = ctx->nb_slices;
+    pp->pSliceDataOffsets = ctx->slice_offsets;
+
+    err = decoder->cudl->cuCtxPushCurrent(decoder->cuda_ctx);
+    if (err != CUDA_SUCCESS)
+        return AVERROR_UNKNOWN;
+
+    err = decoder->cvdl->cuvidDecodePicture(decoder->decoder, &ctx->pic_params);
+    if (err != CUDA_SUCCESS) {
+        av_log(avctx, AV_LOG_ERROR, "Error decoding a picture with CUVID: %d\n",
+               err);
+        ret = AVERROR_UNKNOWN;
+        goto finish;
+    }
+
+finish:
+    decoder->cudl->cuCtxPopCurrent(&dummy);
+
+    return ret;
+}
diff --git a/libavcodec/cuvid.h b/libavcodec/cuvid.h
new file mode 100644
index 0000000000..232e58d6ed
--- /dev/null
+++ b/libavcodec/cuvid.h
@@ -0,0 +1,62 @@
+/*
+ * HW decode acceleration through CUVID
+ *
+ * Copyright (c) 2016 Anton Khirnov
+ *
+ * This file is part of Libav.
+ *
+ * Libav is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * Libav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with Libav; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_CUVID_H
+#define AVCODEC_CUVID_H
+
+#include "compat/cuda/dynlink_loader.h"
+
+#include <stdint.h>
+
+#include "libavutil/buffer.h"
+#include "libavutil/frame.h"
+
+#include "avcodec.h"
+
+typedef struct CUVIDFrame {
+    unsigned int idx;
+    AVBufferRef *idx_ref;
+    AVBufferRef *decoder_ref;
+} CUVIDFrame;
+
+typedef struct CUVIDContext {
+    CUVIDPICPARAMS pic_params;
+
+    AVBufferPool *decoder_pool;
+
+    AVBufferRef  *decoder_ref;
+
+    uint8_t      *bitstream;
+    int           bitstream_len;
+    unsigned int  bitstream_allocated;
+
+    unsigned     *slice_offsets;
+    int           nb_slices;
+    unsigned int  slice_offsets_allocated;
+} CUVIDContext;
+
+int ff_cuvid_decode_init(AVCodecContext *avctx, unsigned int dpb_size);
+int ff_cuvid_decode_uninit(AVCodecContext *avctx);
+int ff_cuvid_start_frame(AVCodecContext *avctx, AVFrame *frame);
+int ff_cuvid_end_frame(AVCodecContext *avctx);
+
+#endif /* AVCODEC_CUVID_H */
diff --git a/libavcodec/cuvid_h264.c b/libavcodec/cuvid_h264.c
new file mode 100644
index 0000000000..06362e9061
--- /dev/null
+++ b/libavcodec/cuvid_h264.c
@@ -0,0 +1,176 @@
+/*
+ * MPEG-4 Part 10 / AVC / H.264 HW decode acceleration through CUVID
+ *
+ * Copyright (c) 2016 Anton Khirnov
+ *
+ * This file is part of Libav.
+ *
+ * Libav is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * Libav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with Libav; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdint.h>
+#include <string.h>
+
+#include "avcodec.h"
+#include "cuvid.h"
+#include "decode.h"
+#include "internal.h"
+#include "h264dec.h"
+
+static void dpb_add(const H264Context *h, CUVIDH264DPBENTRY *dst, const H264Picture *src,
+                    int frame_idx)
+{
+    FrameDecodeData *fdd = (FrameDecodeData*)src->f->opaque_ref->data;
+    const CUVIDFrame *cf = fdd->hwaccel_priv;
+
+    dst->PicIdx             = cf ? cf->idx : -1;
+    dst->FrameIdx           = frame_idx;
+    dst->is_long_term       = src->long_ref;
+    dst->not_existing       = 0;
+    dst->used_for_reference = src->reference & 3;
+    dst->FieldOrderCnt[0]   = src->field_poc[0];
+    dst->FieldOrderCnt[1]   = src->field_poc[1];
+}
+
+static int cuvid_h264_start_frame(AVCodecContext *avctx,
+                                  const uint8_t *buffer, uint32_t size)
+{
+    const H264Context *h = avctx->priv_data;
+    const PPS *pps = h->ps.pps;
+    const SPS *sps = h->ps.sps;
+
+    CUVIDContext       *ctx = avctx->internal->hwaccel_priv_data;
+    CUVIDPICPARAMS      *pp = &ctx->pic_params;
+    CUVIDH264PICPARAMS *ppc = &pp->CodecSpecific.h264;
+    FrameDecodeData *fdd;
+    CUVIDFrame *cf;
+
+    int i, dpb_size, ret;
+
+    ret = ff_cuvid_start_frame(avctx, h->cur_pic_ptr->f);
+    if (ret < 0)
+        return ret;
+
+    fdd = (FrameDecodeData*)h->cur_pic_ptr->f->opaque_ref->data;
+    cf  = (CUVIDFrame*)fdd->hwaccel_priv;
+
+    *pp = (CUVIDPICPARAMS) {
+        .PicWidthInMbs     = h->mb_width,
+        .FrameHeightInMbs  = h->mb_height,
+        .CurrPicIdx        = cf->idx,
+        .field_pic_flag    = FIELD_PICTURE(h),
+        .bottom_field_flag = h->picture_structure == PICT_BOTTOM_FIELD,
+        .second_field      = FIELD_PICTURE(h) && !h->first_field,
+        .ref_pic_flag      = h->nal_ref_idc != 0,
+        .intra_pic_flag    = 0,
+
+        .CodecSpecific.h264 = {
+            .log2_max_frame_num_minus4            = sps->log2_max_frame_num - 4,
+            .pic_order_cnt_type                   = sps->poc_type,
+            .log2_max_pic_order_cnt_lsb_minus4    = FFMAX(sps->log2_max_poc_lsb - 4, 0),
+            .delta_pic_order_always_zero_flag     = sps->delta_pic_order_always_zero_flag,
+            .frame_mbs_only_flag                  = sps->frame_mbs_only_flag,
+            .direct_8x8_inference_flag            = sps->direct_8x8_inference_flag,
+            .num_ref_frames                       = sps->ref_frame_count,
+            .residual_colour_transform_flag       = sps->residual_color_transform_flag,
+            .bit_depth_luma_minus8                = sps->bit_depth_luma - 8,
+            .bit_depth_chroma_minus8              = sps->bit_depth_chroma - 8,
+            .qpprime_y_zero_transform_bypass_flag = sps->transform_bypass,
+
+            .entropy_coding_mode_flag               = pps->cabac,
+            .pic_order_present_flag                 = pps->pic_order_present,
+            .num_ref_idx_l0_active_minus1           = pps->ref_count[0] - 1,
+            .num_ref_idx_l1_active_minus1           = pps->ref_count[1] - 1,
+            .weighted_pred_flag                     = pps->weighted_pred,
+            .weighted_bipred_idc                    = pps->weighted_bipred_idc,
+            .pic_init_qp_minus26                    = pps->init_qp - 26,
+            .deblocking_filter_control_present_flag = pps->deblocking_filter_parameters_present,
+            .redundant_pic_cnt_present_flag         = pps->redundant_pic_cnt_present,
+            .transform_8x8_mode_flag                = pps->transform_8x8_mode,
+            .MbaffFrameFlag                         = sps->mb_aff && !FIELD_PICTURE(h),
+            .constrained_intra_pred_flag            = pps->constrained_intra_pred,
+            .chroma_qp_index_offset                 = pps->chroma_qp_index_offset[0],
+            .second_chroma_qp_index_offset          = pps->chroma_qp_index_offset[1],
+            .ref_pic_flag                           = h->nal_ref_idc != 0,
+            .frame_num                              = h->poc.frame_num,
+            .CurrFieldOrderCnt[0]                   = h->cur_pic_ptr->field_poc[0],
+            .CurrFieldOrderCnt[1]                   = h->cur_pic_ptr->field_poc[1],
+        },
+    };
+
+    memcpy(ppc->WeightScale4x4,    pps->scaling_matrix4,    sizeof(ppc->WeightScale4x4));
+    memcpy(ppc->WeightScale8x8[0], pps->scaling_matrix8[0], sizeof(ppc->WeightScale8x8[0]));
+    memcpy(ppc->WeightScale8x8[1], pps->scaling_matrix8[3], sizeof(ppc->WeightScale8x8[0]));
+
+    dpb_size = 0;
+    for (i = 0; i < h->short_ref_count; i++)
+        dpb_add(h, &ppc->dpb[dpb_size++], h->short_ref[i], h->short_ref[i]->frame_num);
+    for (i = 0; i < 16; i++) {
+        if (h->long_ref[i])
+            dpb_add(h, &ppc->dpb[dpb_size++], h->long_ref[i], i);
+    }
+
+    for (i = dpb_size; i < FF_ARRAY_ELEMS(ppc->dpb); i++)
+        ppc->dpb[i].PicIdx = -1;
+
+    return 0;
+}
+
+static int cuvid_h264_decode_slice(AVCodecContext *avctx, const uint8_t *buffer,
+                                   uint32_t size)
+{
+    CUVIDContext *ctx = avctx->internal->hwaccel_priv_data;
+    void *tmp;
+
+    tmp = av_fast_realloc(ctx->bitstream, &ctx->bitstream_allocated,
+                          ctx->bitstream_len + size + 3);
+    if (!tmp)
+        return AVERROR(ENOMEM);
+    ctx->bitstream = tmp;
+
+    tmp = av_fast_realloc(ctx->slice_offsets, &ctx->slice_offsets_allocated,
+                          (ctx->nb_slices + 1) * sizeof(*ctx->slice_offsets));
+    if (!tmp)
+        return AVERROR(ENOMEM);
+    ctx->slice_offsets = tmp;
+
+    AV_WB24(ctx->bitstream + ctx->bitstream_len, 1);
+    memcpy(ctx->bitstream + ctx->bitstream_len + 3, buffer, size);
+    ctx->slice_offsets[ctx->nb_slices] = ctx->bitstream_len ;
+    ctx->bitstream_len += size + 3;
+    ctx->nb_slices++;
+
+    return 0;
+}
+
+static int cuvid_h264_decode_init(AVCodecContext *avctx)
+{
+    const H264Context *h = avctx->priv_data;
+    const SPS       *sps = h->ps.sps;
+    return ff_cuvid_decode_init(avctx, sps->ref_frame_count + sps->num_reorder_frames);
+}
+
+AVHWAccel ff_h264_cuvid_hwaccel_hwaccel = {
+    .name                 = "h264_cuvid_hwaccel",
+    .type                 = AVMEDIA_TYPE_VIDEO,
+    .id                   = AV_CODEC_ID_H264,
+    .pix_fmt              = AV_PIX_FMT_CUDA,
+    .start_frame          = cuvid_h264_start_frame,
+    .end_frame            = ff_cuvid_end_frame,
+    .decode_slice         = cuvid_h264_decode_slice,
+    .init                 = cuvid_h264_decode_init,
+    .uninit               = ff_cuvid_decode_uninit,
+    .priv_data_size       = sizeof(CUVIDContext),
+};
diff --git a/libavcodec/h264_slice.c b/libavcodec/h264_slice.c
index 35dcabd611..9a3c228979 100644
--- a/libavcodec/h264_slice.c
+++ b/libavcodec/h264_slice.c
@@ -756,7 +756,8 @@ static enum AVPixelFormat get_pixel_format(H264Context *h, int force_callback)
                      (CONFIG_H264_D3D11VA_HWACCEL * 2) + \
                      CONFIG_H264_VAAPI_HWACCEL + \
                      CONFIG_H264_VIDEOTOOLBOX_HWACCEL + \
-                     CONFIG_H264_VDPAU_HWACCEL)
+                     CONFIG_H264_VDPAU_HWACCEL + \
+                     CONFIG_H264_CUVID_HWACCEL)
     enum AVPixelFormat pix_fmts[HWACCEL_MAX + 2], *fmt = pix_fmts;
     const enum AVPixelFormat *choices = pix_fmts;
     int i;
@@ -809,6 +810,9 @@ static enum AVPixelFormat get_pixel_format(H264Context *h, int force_callback)
     case 8:
 #if CONFIG_H264_VDPAU_HWACCEL
         *fmt++ = AV_PIX_FMT_VDPAU;
+#endif
+#if CONFIG_H264_CUVID_HWACCEL
+        *fmt++ = AV_PIX_FMT_CUDA;
 #endif
         if (CHROMA444(h)) {
             if (h->avctx->colorspace == AVCOL_SPC_RGB)
-- 
2.14.2


From 062f7a6e13d118af5c39c9df6e1eed0fc9396cd0 Mon Sep 17 00:00:00 2001
From: wm4 <nfxjfg@googlemail.com>
Date: Tue, 3 Oct 2017 17:43:13 +0200
Subject: [PATCH 13/16] avcodec/decode: add missing \n to log message

---
 libavcodec/decode.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libavcodec/decode.c b/libavcodec/decode.c
index d7cff3e5df..9909452e64 100644
--- a/libavcodec/decode.c
+++ b/libavcodec/decode.c
@@ -1201,7 +1201,7 @@ static int setup_hwaccel(AVCodecContext *avctx,
 
     if (!hwa) {
         av_log(avctx, AV_LOG_ERROR,
-               "Could not find an AVHWAccel for the pixel format: %s",
+               "Could not find an AVHWAccel for the pixel format: %s\n",
                name);
         return AVERROR(ENOENT);
     }
-- 
2.14.2


From bdddc120a90566a02964bd7faabb13be42127bdb Mon Sep 17 00:00:00 2001
From: Anton Khirnov <anton@khirnov.net>
Date: Mon, 24 Jul 2017 11:41:31 +0200
Subject: [PATCH 14/16] hevcdec: set the active SPS before calling get_format()

This way the SPS is available to the hwaccel init code.
---
 libavcodec/hevcdec.c | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/libavcodec/hevcdec.c b/libavcodec/hevcdec.c
index 2e4add2ae3..d98fec3b8f 100644
--- a/libavcodec/hevcdec.c
+++ b/libavcodec/hevcdec.c
@@ -503,13 +503,14 @@ static int hls_slice_header(HEVCContext *s)
         }
         ff_hevc_clear_refs(s);
 
+        ret = set_sps(s, sps, sps->pix_fmt);
+        if (ret < 0)
+            return ret;
+
         pix_fmt = get_format(s, sps);
         if (pix_fmt < 0)
             return pix_fmt;
-
-        ret = set_sps(s, sps, pix_fmt);
-        if (ret < 0)
-            return ret;
+        s->avctx->pix_fmt = pix_fmt;
 
         s->seq_decode = (s->seq_decode + 1) & 0xff;
         s->max_ra     = INT_MAX;
-- 
2.14.2


From 6a8bbb7fca17dc8c2cb86f7e1bed685bdd7909c5 Mon Sep 17 00:00:00 2001
From: Anton Khirnov <anton@khirnov.net>
Date: Sat, 11 Feb 2017 16:49:34 +0100
Subject: [PATCH 15/16] hevcdec: add a CUVID hwaccel

---
 Changelog               |   2 +-
 configure               |   2 +
 libavcodec/Makefile     |   1 +
 libavcodec/allcodecs.c  |   1 +
 libavcodec/cuvid.c      |   1 +
 libavcodec/cuvid_hevc.c | 279 ++++++++++++++++++++++++++++++++++++++++++++++++
 libavcodec/hevcdec.c    |   9 +-
 7 files changed, 293 insertions(+), 2 deletions(-)
 create mode 100644 libavcodec/cuvid_hevc.c

diff --git a/Changelog b/Changelog
index 2fda8d8263..4ebbf8d482 100644
--- a/Changelog
+++ b/Changelog
@@ -97,7 +97,7 @@ version 3.3:
 - Removed asyncts filter (use af_aresample instead)
 - Intel QSV-accelerated VP8 video decoding
 - VAAPI-accelerated deinterlacing
-- NVIDIA CUVID-accelerated H.264 hwaccel decoding
+- NVIDIA CUVID-accelerated H.264 and HEVC decoding
 
 
 version 3.2:
diff --git a/configure b/configure
index 0f6f612bd6..02dd6da1ee 100755
--- a/configure
+++ b/configure
@@ -2685,6 +2685,8 @@ h264_videotoolbox_hwaccel_deps="videotoolbox"
 h264_videotoolbox_hwaccel_select="h264_decoder"
 hevc_cuvid_hwaccel_deps="cuda cuvid"
 hevc_cuvid_hwaccel_select="hevc_cuvid_decoder"
+hevc_cuvid_hwaccel_hwaccel_deps="cuda cuvid_hwaccel"
+hevc_cuvid_hwaccel_hwaccel_select="hevc_decoder"
 hevc_d3d11va_hwaccel_deps="d3d11va DXVA_PicParams_HEVC"
 hevc_d3d11va_hwaccel_select="hevc_decoder"
 hevc_mediacodec_hwaccel_deps="mediacodec"
diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index 17019748c4..5c7c463f64 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -838,6 +838,7 @@ OBJS-$(CONFIG_H264_QSV_HWACCEL)           += qsvdec_h2645.o
 OBJS-$(CONFIG_H264_VAAPI_HWACCEL)         += vaapi_h264.o
 OBJS-$(CONFIG_H264_VDPAU_HWACCEL)         += vdpau_h264.o
 OBJS-$(CONFIG_H264_VIDEOTOOLBOX_HWACCEL)  += videotoolbox.o
+OBJS-$(CONFIG_HEVC_CUVID_HWACCEL_HWACCEL) += cuvid_hevc.o
 OBJS-$(CONFIG_HEVC_D3D11VA_HWACCEL)       += dxva2_hevc.o
 OBJS-$(CONFIG_HEVC_DXVA2_HWACCEL)         += dxva2_hevc.o
 OBJS-$(CONFIG_HEVC_QSV_HWACCEL)           += qsvdec_h2645.o
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index 880950f039..e109a2c64a 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -76,6 +76,7 @@ static void register_all(void)
     REGISTER_HWACCEL(H264_VDPAU,        h264_vdpau);
     REGISTER_HWACCEL(H264_VIDEOTOOLBOX, h264_videotoolbox);
     REGISTER_HWACCEL(HEVC_CUVID,        hevc_cuvid);
+    REGISTER_HWACCEL(HEVC_CUVID,        hevc_cuvid_hwaccel);
     REGISTER_HWACCEL(HEVC_D3D11VA,      hevc_d3d11va);
     REGISTER_HWACCEL(HEVC_D3D11VA2,     hevc_d3d11va2);
     REGISTER_HWACCEL(HEVC_DXVA2,        hevc_dxva2);
diff --git a/libavcodec/cuvid.c b/libavcodec/cuvid.c
index c90ca38a84..45e7851f22 100644
--- a/libavcodec/cuvid.c
+++ b/libavcodec/cuvid.c
@@ -53,6 +53,7 @@ static int map_avcodec_id(enum AVCodecID id)
 {
     switch (id) {
     case AV_CODEC_ID_H264: return cudaVideoCodec_H264;
+    case AV_CODEC_ID_HEVC: return cudaVideoCodec_HEVC;
     }
     return -1;
 }
diff --git a/libavcodec/cuvid_hevc.c b/libavcodec/cuvid_hevc.c
new file mode 100644
index 0000000000..9993272828
--- /dev/null
+++ b/libavcodec/cuvid_hevc.c
@@ -0,0 +1,279 @@
+/*
+ * HEVC HW decode acceleration through CUVID
+ *
+ * Copyright (c) 2017 Anton Khirnov
+ *
+ * This file is part of Libav.
+ *
+ * Libav is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * Libav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with Libav; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdint.h>
+#include <string.h>
+
+#include "avcodec.h"
+#include "cuvid.h"
+#include "decode.h"
+#include "internal.h"
+#include "hevcdec.h"
+#include "hevc_data.h"
+
+static void dpb_add(CUVIDHEVCPICPARAMS *pp, int idx, const HEVCFrame *src)
+{
+    FrameDecodeData *fdd = (FrameDecodeData*)src->frame->opaque_ref->data;
+    const CUVIDFrame *cf = fdd->hwaccel_priv;
+
+    pp->RefPicIdx[idx]      = cf ? cf->idx : -1;
+    pp->PicOrderCntVal[idx] = src->poc;
+    pp->IsLongTerm[idx]     = !!(src->flags & HEVC_FRAME_FLAG_LONG_REF);
+}
+
+static void fill_scaling_lists(CUVIDHEVCPICPARAMS *ppc, const HEVCContext *s)
+{
+    const ScalingList *sl = s->ps.pps->scaling_list_data_present_flag ?
+                            &s->ps.pps->scaling_list : &s->ps.sps->scaling_list;
+    int i, j, pos;
+
+    for (i = 0; i < 6; i++) {
+        for (j = 0; j < 16; j++) {
+            pos = 4 * ff_hevc_diag_scan4x4_y[j] + ff_hevc_diag_scan4x4_x[j];
+            ppc->ScalingList4x4[i][j] = sl->sl[0][i][pos];
+        }
+
+        for (j = 0; j < 64; j++) {
+            pos = 8 * ff_hevc_diag_scan8x8_y[j] + ff_hevc_diag_scan8x8_x[j];
+            ppc->ScalingList8x8[i][j]   = sl->sl[1][i][pos];
+            ppc->ScalingList16x16[i][j] = sl->sl[2][i][pos];
+
+            if (i < 2)
+                ppc->ScalingList32x32[i][j] = sl->sl[3][i][pos];
+        }
+    }
+
+    memcpy(ppc->ScalingListDCCoeff16x16, sl->sl_dc[0], sizeof(ppc->ScalingListDCCoeff16x16));
+    memcpy(ppc->ScalingListDCCoeff32x32, sl->sl_dc[1], sizeof(ppc->ScalingListDCCoeff32x32));
+}
+
+static int cuvid_hevc_start_frame(AVCodecContext *avctx,
+                                  const uint8_t *buffer, uint32_t size)
+{
+    const HEVCContext *s = avctx->priv_data;
+    const HEVCPPS *pps = s->ps.pps;
+    const HEVCSPS *sps = s->ps.sps;
+
+    CUVIDContext       *ctx = avctx->internal->hwaccel_priv_data;
+    CUVIDPICPARAMS      *pp = &ctx->pic_params;
+    CUVIDHEVCPICPARAMS *ppc = &pp->CodecSpecific.hevc;
+    FrameDecodeData *fdd;
+    CUVIDFrame *cf;
+
+    int i, j, dpb_size, ret;
+
+    ret = ff_cuvid_start_frame(avctx, s->ref->frame);
+    if (ret < 0)
+        return ret;
+
+    fdd = (FrameDecodeData*)s->ref->frame->opaque_ref->data;
+    cf  = (CUVIDFrame*)fdd->hwaccel_priv;
+
+    *pp = (CUVIDPICPARAMS) {
+        .PicWidthInMbs     = sps->width  / 16,
+        .FrameHeightInMbs  = sps->height / 16,
+        .CurrPicIdx        = cf->idx,
+        .ref_pic_flag      = 1,
+        .intra_pic_flag    = 0,
+
+        .CodecSpecific.hevc = {
+            .pic_width_in_luma_samples                    = sps->width,
+            .pic_height_in_luma_samples                   = sps->height,
+            .log2_min_luma_coding_block_size_minus3       = sps->log2_min_cb_size - 3,
+            .log2_diff_max_min_luma_coding_block_size     = sps->log2_diff_max_min_coding_block_size,
+            .log2_min_transform_block_size_minus2         = sps->log2_min_tb_size - 2,
+            .log2_diff_max_min_transform_block_size       = sps->log2_max_trafo_size - sps->log2_min_tb_size,
+            .pcm_enabled_flag                             = sps->pcm_enabled_flag,
+            .log2_min_pcm_luma_coding_block_size_minus3   = sps->pcm_enabled_flag ? sps->pcm.log2_min_pcm_cb_size - 3 : 0,
+            .log2_diff_max_min_pcm_luma_coding_block_size = sps->pcm.log2_max_pcm_cb_size - sps->pcm.log2_min_pcm_cb_size,
+            .pcm_sample_bit_depth_luma_minus1             = sps->pcm_enabled_flag ? sps->pcm.bit_depth - 1 : 0,
+            .pcm_sample_bit_depth_chroma_minus1           = sps->pcm_enabled_flag ? sps->pcm.bit_depth_chroma - 1 : 0,
+            .pcm_loop_filter_disabled_flag                = sps->pcm.loop_filter_disable_flag,
+            .strong_intra_smoothing_enabled_flag          = sps->sps_strong_intra_smoothing_enable_flag,
+            .max_transform_hierarchy_depth_intra          = sps->max_transform_hierarchy_depth_intra,
+            .max_transform_hierarchy_depth_inter          = sps->max_transform_hierarchy_depth_inter,
+            .amp_enabled_flag                             = sps->amp_enabled_flag,
+            .separate_colour_plane_flag                   = sps->separate_colour_plane_flag,
+            .log2_max_pic_order_cnt_lsb_minus4            = sps->log2_max_poc_lsb - 4,
+            .num_short_term_ref_pic_sets                  = sps->nb_st_rps,
+            .long_term_ref_pics_present_flag              = sps->long_term_ref_pics_present_flag,
+            .num_long_term_ref_pics_sps                   = sps->num_long_term_ref_pics_sps,
+            .sps_temporal_mvp_enabled_flag                = sps->sps_temporal_mvp_enabled_flag,
+            .sample_adaptive_offset_enabled_flag          = sps->sao_enabled,
+            .scaling_list_enable_flag                     = sps->scaling_list_enable_flag,
+            .IrapPicFlag                                  = IS_IRAP(s),
+            .IdrPicFlag                                   = IS_IDR(s),
+            .bit_depth_luma_minus8                        = sps->bit_depth - 8,
+            .bit_depth_chroma_minus8                      = sps->bit_depth - 8,
+
+            .dependent_slice_segments_enabled_flag        = pps->dependent_slice_segments_enabled_flag,
+            .slice_segment_header_extension_present_flag  = pps->slice_header_extension_present_flag,
+            .sign_data_hiding_enabled_flag                = pps->sign_data_hiding_flag,
+            .cu_qp_delta_enabled_flag                     = pps->cu_qp_delta_enabled_flag,
+            .diff_cu_qp_delta_depth                       = pps->diff_cu_qp_delta_depth,
+            .init_qp_minus26                              = pps->pic_init_qp_minus26,
+            .pps_cb_qp_offset                             = pps->cb_qp_offset,
+            .pps_cr_qp_offset                             = pps->cr_qp_offset,
+            .constrained_intra_pred_flag                  = pps->constrained_intra_pred_flag,
+            .weighted_pred_flag                           = pps->weighted_pred_flag,
+            .weighted_bipred_flag                         = pps->weighted_bipred_flag,
+            .transform_skip_enabled_flag                  = pps->transform_skip_enabled_flag,
+            .transquant_bypass_enabled_flag               = pps->transquant_bypass_enable_flag,
+            .entropy_coding_sync_enabled_flag             = pps->entropy_coding_sync_enabled_flag,
+            .log2_parallel_merge_level_minus2             = pps->log2_parallel_merge_level - 2,
+            .num_extra_slice_header_bits                  = pps->num_extra_slice_header_bits,
+            .loop_filter_across_tiles_enabled_flag        = pps->loop_filter_across_tiles_enabled_flag,
+            .loop_filter_across_slices_enabled_flag       = pps->seq_loop_filter_across_slices_enabled_flag,
+            .output_flag_present_flag                     = pps->output_flag_present_flag,
+            .num_ref_idx_l0_default_active_minus1         = pps->num_ref_idx_l0_default_active - 1,
+            .num_ref_idx_l1_default_active_minus1         = pps->num_ref_idx_l1_default_active - 1,
+            .lists_modification_present_flag              = pps->lists_modification_present_flag,
+            .cabac_init_present_flag                      = pps->cabac_init_present_flag,
+            .pps_slice_chroma_qp_offsets_present_flag     = pps->pic_slice_level_chroma_qp_offsets_present_flag,
+            .deblocking_filter_override_enabled_flag      = pps->deblocking_filter_override_enabled_flag,
+            .pps_deblocking_filter_disabled_flag          = pps->disable_dbf,
+            .pps_beta_offset_div2                         = pps->beta_offset / 2,
+            .pps_tc_offset_div2                           = pps->tc_offset / 2,
+            .tiles_enabled_flag                           = pps->tiles_enabled_flag,
+            .uniform_spacing_flag                         = pps->uniform_spacing_flag,
+            .num_tile_columns_minus1                      = pps->num_tile_columns - 1,
+            .num_tile_rows_minus1                         = pps->num_tile_rows - 1,
+
+            .NumBitsForShortTermRPSInSlice                = s->sh.short_term_rps ? s->sh.short_term_ref_pic_set_size : 0,
+            .NumDeltaPocsOfRefRpsIdx                      = s->sh.short_term_rps ? s->sh.short_term_rps->rps_idx_num_delta_pocs : 0,
+            .NumPocTotalCurr                              = s->rps[ST_CURR_BEF].nb_refs + s->rps[ST_CURR_AFT].nb_refs +
+                                                            s->rps[LT_CURR].nb_refs,
+            .NumPocStCurrBefore                           = s->rps[ST_CURR_BEF].nb_refs,
+            .NumPocStCurrAfter                            = s->rps[ST_CURR_AFT].nb_refs,
+            .NumPocLtCurr                                 = s->rps[LT_CURR].nb_refs,
+            .CurrPicOrderCntVal                           = s->ref->poc,
+        },
+    };
+
+    if (pps->num_tile_columns > FF_ARRAY_ELEMS(ppc->column_width_minus1) ||
+        pps->num_tile_rows    > FF_ARRAY_ELEMS(ppc->row_height_minus1)) {
+        av_log(avctx, AV_LOG_ERROR, "Too many tiles\n");
+        return AVERROR(ENOSYS);
+    }
+    for (i = 0; i < pps->num_tile_columns; i++)
+        ppc->column_width_minus1[i] = pps->column_width[i] - 1;
+    for (i = 0; i < pps->num_tile_rows; i++)
+        ppc->row_height_minus1[i] = pps->row_height[i] - 1;
+
+    if (s->rps[LT_CURR].nb_refs     > FF_ARRAY_ELEMS(ppc->RefPicSetLtCurr)       ||
+        s->rps[ST_CURR_BEF].nb_refs > FF_ARRAY_ELEMS(ppc->RefPicSetStCurrBefore) ||
+        s->rps[ST_CURR_AFT].nb_refs > FF_ARRAY_ELEMS(ppc->RefPicSetStCurrAfter)) {
+        av_log(avctx, AV_LOG_ERROR, "Too many reference frames\n");
+        return AVERROR(ENOSYS);
+    }
+
+    dpb_size = 0;
+    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {
+        const HEVCFrame *ref = &s->DPB[i];
+        if (!(ref->flags & (HEVC_FRAME_FLAG_SHORT_REF | HEVC_FRAME_FLAG_LONG_REF)))
+            continue;
+        if (dpb_size >= FF_ARRAY_ELEMS(ppc->RefPicIdx)) {
+            av_log(avctx, AV_LOG_ERROR, "Too many reference frames\n");
+            return AVERROR_INVALIDDATA;
+        }
+        dpb_add(ppc, dpb_size++, ref);
+
+    }
+    for (i = dpb_size; i < FF_ARRAY_ELEMS(ppc->RefPicIdx); i++)
+        ppc->RefPicIdx[i] = -1;
+
+    for (i = 0; i < s->rps[ST_CURR_BEF].nb_refs; i++) {
+        for (j = 0; j < dpb_size; j++) {
+            if (ppc->PicOrderCntVal[j] == s->rps[ST_CURR_BEF].list[i]) {
+                ppc->RefPicSetStCurrBefore[i] = j;
+                break;
+            }
+        }
+    }
+    for (i = 0; i < s->rps[ST_CURR_AFT].nb_refs; i++) {
+        for (j = 0; j < dpb_size; j++) {
+            if (ppc->PicOrderCntVal[j] == s->rps[ST_CURR_AFT].list[i]) {
+                ppc->RefPicSetStCurrAfter[i] = j;
+                break;
+            }
+        }
+    }
+    for (i = 0; i < s->rps[LT_CURR].nb_refs; i++) {
+        for (j = 0; j < dpb_size; j++) {
+            if (ppc->PicOrderCntVal[j] == s->rps[LT_CURR].list[i]) {
+                ppc->RefPicSetLtCurr[i] = j;
+                break;
+            }
+        }
+    }
+
+    fill_scaling_lists(ppc, s);
+
+    return 0;
+}
+
+static int cuvid_hevc_decode_slice(AVCodecContext *avctx, const uint8_t *buffer,
+                                   uint32_t size)
+{
+    CUVIDContext *ctx = avctx->internal->hwaccel_priv_data;
+    void *tmp;
+
+    tmp = av_fast_realloc(ctx->bitstream, &ctx->bitstream_allocated,
+                          ctx->bitstream_len + size + 3);
+    if (!tmp)
+        return AVERROR(ENOMEM);
+    ctx->bitstream = tmp;
+
+    tmp = av_fast_realloc(ctx->slice_offsets, &ctx->slice_offsets_allocated,
+                          (ctx->nb_slices + 1) * sizeof(*ctx->slice_offsets));
+    if (!tmp)
+        return AVERROR(ENOMEM);
+    ctx->slice_offsets = tmp;
+
+    AV_WB24(ctx->bitstream + ctx->bitstream_len, 1);
+    memcpy(ctx->bitstream + ctx->bitstream_len + 3, buffer, size);
+    ctx->slice_offsets[ctx->nb_slices] = ctx->bitstream_len ;
+    ctx->bitstream_len += size + 3;
+    ctx->nb_slices++;
+
+    return 0;
+}
+
+static int cuvid_hevc_decode_init(AVCodecContext *avctx)
+{
+    const HEVCContext *s = avctx->priv_data;
+    const HEVCSPS *sps = s->ps.sps;
+    return ff_cuvid_decode_init(avctx, sps->temporal_layer[sps->max_sub_layers - 1].max_dec_pic_buffering + 1);
+}
+
+AVHWAccel ff_hevc_cuvid_hwaccel_hwaccel = {
+    .name                 = "hevc_cuvid",
+    .type                 = AVMEDIA_TYPE_VIDEO,
+    .id                   = AV_CODEC_ID_HEVC,
+    .pix_fmt              = AV_PIX_FMT_CUDA,
+    .start_frame          = cuvid_hevc_start_frame,
+    .end_frame            = ff_cuvid_end_frame,
+    .decode_slice         = cuvid_hevc_decode_slice,
+    .init                 = cuvid_hevc_decode_init,
+    .uninit               = ff_cuvid_decode_uninit,
+    .priv_data_size       = sizeof(CUVIDContext),
+};
diff --git a/libavcodec/hevcdec.c b/libavcodec/hevcdec.c
index d98fec3b8f..c5c5ba1407 100644
--- a/libavcodec/hevcdec.c
+++ b/libavcodec/hevcdec.c
@@ -356,7 +356,8 @@ static enum AVPixelFormat get_format(HEVCContext *s, const HEVCSPS *sps)
                      CONFIG_HEVC_D3D11VA_HWACCEL * 2 + \
                      CONFIG_HEVC_VAAPI_HWACCEL + \
                      CONFIG_HEVC_VIDEOTOOLBOX_HWACCEL + \
-                     CONFIG_HEVC_VDPAU_HWACCEL)
+                     CONFIG_HEVC_VDPAU_HWACCEL + \
+                     CONFIG_HEVC_CUVID_HWACCEL)
     enum AVPixelFormat pix_fmts[HWACCEL_MAX + 2], *fmt = pix_fmts;
 
     switch (sps->pix_fmt) {
@@ -375,6 +376,9 @@ static enum AVPixelFormat get_format(HEVCContext *s, const HEVCSPS *sps)
 #if CONFIG_HEVC_VDPAU_HWACCEL
         *fmt++ = AV_PIX_FMT_VDPAU;
 #endif
+#if CONFIG_HEVC_CUVID_HWACCEL
+        *fmt++ = AV_PIX_FMT_CUDA;
+#endif
 #if CONFIG_HEVC_VIDEOTOOLBOX_HWACCEL
         *fmt++ = AV_PIX_FMT_VIDEOTOOLBOX;
 #endif
@@ -392,6 +396,9 @@ static enum AVPixelFormat get_format(HEVCContext *s, const HEVCSPS *sps)
 #endif
 #if CONFIG_HEVC_VIDEOTOOLBOX_HWACCEL
         *fmt++ = AV_PIX_FMT_VIDEOTOOLBOX;
+#endif
+#if CONFIG_HEVC_CUVID_HWACCEL
+        *fmt++ = AV_PIX_FMT_CUDA;
 #endif
         break;
     }
-- 
2.14.2


From d91efdaadad7fed7f4782779b2205c48e856aeda Mon Sep 17 00:00:00 2001
From: wm4 <nfxjfg@googlemail.com>
Date: Sat, 28 Oct 2017 19:53:38 +0200
Subject: [PATCH 16/16] cuvid: add frames_params support

Needed by whatever uses the API for filling in hwaccel frames params,
such as mpv.
---
 libavcodec/cuvid.c      | 74 ++++++++++++++++++++++++++++---------------------
 libavcodec/cuvid.h      |  5 +++-
 libavcodec/cuvid_h264.c |  8 ++++--
 libavcodec/cuvid_hevc.c |  8 ++++--
 4 files changed, 57 insertions(+), 38 deletions(-)

diff --git a/libavcodec/cuvid.c b/libavcodec/cuvid.c
index 45e7851f22..ca6809f71e 100644
--- a/libavcodec/cuvid.c
+++ b/libavcodec/cuvid.c
@@ -185,7 +185,7 @@ int ff_cuvid_decode_uninit(AVCodecContext *avctx)
     return 0;
 }
 
-int ff_cuvid_decode_init(AVCodecContext *avctx, unsigned int dpb_size)
+int ff_cuvid_decode_init(AVCodecContext *avctx)
 {
     CUVIDContext *ctx = avctx->internal->hwaccel_priv_data;
 
@@ -214,37 +214,12 @@ int ff_cuvid_decode_init(AVCodecContext *avctx, unsigned int dpb_size)
         return AVERROR(ENOSYS);
     }
 
-    if (avctx->thread_type & FF_THREAD_FRAME)
-        dpb_size += avctx->thread_count;
-
     if (!avctx->hw_frames_ctx) {
-        AVHWFramesContext *frames_ctx;
-
-        if (!avctx->hw_device_ctx) {
-            av_log(avctx, AV_LOG_ERROR, "A hardware device or frames context "
-                   "is required for CUVID decoding.\n");
-            return AVERROR(EINVAL);
-        }
-
-        avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx);
-        if (!avctx->hw_frames_ctx)
-            return AVERROR(ENOMEM);
-        frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;
-
-        frames_ctx->format            = AV_PIX_FMT_CUDA;
-        frames_ctx->width             = avctx->coded_width;
-        frames_ctx->height            = avctx->coded_height;
-        frames_ctx->sw_format         = AV_PIX_FMT_NV12;
-        frames_ctx->sw_format         = sw_desc->comp[0].depth > 8 ?
-                                        AV_PIX_FMT_P010 : AV_PIX_FMT_NV12;
-        frames_ctx->initial_pool_size = dpb_size;
-
-        ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);
-        if (ret < 0) {
-            av_log(avctx, AV_LOG_ERROR, "Error initializing internal frames context\n");
+        ret = ff_decode_get_hw_frames_ctx(avctx, AV_HWDEVICE_TYPE_CUDA);
+        if (ret < 0)
             return ret;
-        }
     }
+
     frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;
 
     params.ulWidth             = avctx->coded_width;
@@ -256,7 +231,7 @@ int ff_cuvid_decode_init(AVCodecContext *avctx, unsigned int dpb_size)
                                  cudaVideoSurfaceFormat_P016 : cudaVideoSurfaceFormat_NV12;
     params.CodecType           = cuvid_codec_type;
     params.ChromaFormat        = cuvid_chroma_format;
-    params.ulNumDecodeSurfaces = dpb_size;
+    params.ulNumDecodeSurfaces = frames_ctx->initial_pool_size;
     params.ulNumOutputSurfaces = 1;
 
     ret = cuvid_decoder_create(&ctx->decoder_ref, frames_ctx->device_ref, &params, avctx);
@@ -268,7 +243,7 @@ int ff_cuvid_decode_init(AVCodecContext *avctx, unsigned int dpb_size)
         ret = AVERROR(ENOMEM);
         goto fail;
     }
-    pool->dpb_size = dpb_size;
+    pool->dpb_size = frames_ctx->initial_pool_size;
 
     ctx->decoder_pool = av_buffer_pool_init2(sizeof(int), pool,
                                              cuvid_decoder_frame_alloc, av_free);
@@ -430,3 +405,40 @@ finish:
 
     return ret;
 }
+
+int ff_cuvid_frame_params(AVCodecContext *avctx,
+                          AVBufferRef *hw_frames_ctx,
+                          int dpb_size)
+{
+    AVHWFramesContext *frames_ctx = (AVHWFramesContext*)hw_frames_ctx->data;
+    const AVPixFmtDescriptor *sw_desc;
+    int cuvid_codec_type, cuvid_chroma_format;
+
+    sw_desc = av_pix_fmt_desc_get(avctx->sw_pix_fmt);
+    if (!sw_desc)
+        return AVERROR_BUG;
+
+    cuvid_codec_type = map_avcodec_id(avctx->codec_id);
+    if (cuvid_codec_type < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Unsupported codec ID\n");
+        return AVERROR_BUG;
+    }
+
+    cuvid_chroma_format = map_chroma_format(avctx->sw_pix_fmt);
+    if (cuvid_chroma_format < 0) {
+        av_log(avctx, AV_LOG_VERBOSE, "Unsupported chroma format\n");
+        return AVERROR(EINVAL);
+    }
+
+    if (avctx->thread_type & FF_THREAD_FRAME)
+        dpb_size += avctx->thread_count;
+
+    frames_ctx->format            = AV_PIX_FMT_CUDA;
+    frames_ctx->width             = avctx->coded_width;
+    frames_ctx->height            = avctx->coded_height;
+    frames_ctx->sw_format         = sw_desc->comp[0].depth > 8 ?
+                                    AV_PIX_FMT_P010 : AV_PIX_FMT_NV12;
+    frames_ctx->initial_pool_size = dpb_size;
+
+    return 0;
+}
diff --git a/libavcodec/cuvid.h b/libavcodec/cuvid.h
index 232e58d6ed..552efdb211 100644
--- a/libavcodec/cuvid.h
+++ b/libavcodec/cuvid.h
@@ -54,9 +54,12 @@ typedef struct CUVIDContext {
     unsigned int  slice_offsets_allocated;
 } CUVIDContext;
 
-int ff_cuvid_decode_init(AVCodecContext *avctx, unsigned int dpb_size);
+int ff_cuvid_decode_init(AVCodecContext *avctx);
 int ff_cuvid_decode_uninit(AVCodecContext *avctx);
 int ff_cuvid_start_frame(AVCodecContext *avctx, AVFrame *frame);
 int ff_cuvid_end_frame(AVCodecContext *avctx);
+int ff_cuvid_frame_params(AVCodecContext *avctx,
+                          AVBufferRef *hw_frames_ctx,
+                          int dpb_size);
 
 #endif /* AVCODEC_CUVID_H */
diff --git a/libavcodec/cuvid_h264.c b/libavcodec/cuvid_h264.c
index 06362e9061..84abe04c76 100644
--- a/libavcodec/cuvid_h264.c
+++ b/libavcodec/cuvid_h264.c
@@ -155,11 +155,12 @@ static int cuvid_h264_decode_slice(AVCodecContext *avctx, const uint8_t *buffer,
     return 0;
 }
 
-static int cuvid_h264_decode_init(AVCodecContext *avctx)
+static int cuvid_h264_frame_params(AVCodecContext *avctx,
+                                   AVBufferRef *hw_frames_ctx)
 {
     const H264Context *h = avctx->priv_data;
     const SPS       *sps = h->ps.sps;
-    return ff_cuvid_decode_init(avctx, sps->ref_frame_count + sps->num_reorder_frames);
+    return ff_cuvid_frame_params(avctx, hw_frames_ctx, sps->ref_frame_count + sps->num_reorder_frames);
 }
 
 AVHWAccel ff_h264_cuvid_hwaccel_hwaccel = {
@@ -170,7 +171,8 @@ AVHWAccel ff_h264_cuvid_hwaccel_hwaccel = {
     .start_frame          = cuvid_h264_start_frame,
     .end_frame            = ff_cuvid_end_frame,
     .decode_slice         = cuvid_h264_decode_slice,
-    .init                 = cuvid_h264_decode_init,
+    .frame_params         = cuvid_h264_frame_params,
+    .init                 = ff_cuvid_decode_init,
     .uninit               = ff_cuvid_decode_uninit,
     .priv_data_size       = sizeof(CUVIDContext),
 };
diff --git a/libavcodec/cuvid_hevc.c b/libavcodec/cuvid_hevc.c
index 9993272828..77ecef8ef6 100644
--- a/libavcodec/cuvid_hevc.c
+++ b/libavcodec/cuvid_hevc.c
@@ -258,11 +258,12 @@ static int cuvid_hevc_decode_slice(AVCodecContext *avctx, const uint8_t *buffer,
     return 0;
 }
 
-static int cuvid_hevc_decode_init(AVCodecContext *avctx)
+static int cuvid_hevc_frame_params(AVCodecContext *avctx,
+                                   AVBufferRef *hw_frames_ctx)
 {
     const HEVCContext *s = avctx->priv_data;
     const HEVCSPS *sps = s->ps.sps;
-    return ff_cuvid_decode_init(avctx, sps->temporal_layer[sps->max_sub_layers - 1].max_dec_pic_buffering + 1);
+    return ff_cuvid_frame_params(avctx, hw_frames_ctx, sps->temporal_layer[sps->max_sub_layers - 1].max_dec_pic_buffering + 1);
 }
 
 AVHWAccel ff_hevc_cuvid_hwaccel_hwaccel = {
@@ -273,7 +274,8 @@ AVHWAccel ff_hevc_cuvid_hwaccel_hwaccel = {
     .start_frame          = cuvid_hevc_start_frame,
     .end_frame            = ff_cuvid_end_frame,
     .decode_slice         = cuvid_hevc_decode_slice,
-    .init                 = cuvid_hevc_decode_init,
+    .frame_params         = cuvid_hevc_frame_params,
+    .init                 = ff_cuvid_decode_init,
     .uninit               = ff_cuvid_decode_uninit,
     .priv_data_size       = sizeof(CUVIDContext),
 };
-- 
2.14.2

